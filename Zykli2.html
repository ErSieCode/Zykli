<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MeinZyklus - Tracking App</title>
    <style>
        :root {
            --primary-color: #ff6b6b;
            --primary-light: #ffb8b8;
            --primary-dark: #e74c4c;
            --secondary-color: #ff9e7d;
            --tertiary-color: #ffcc8e;
            --fertile-color: #ffc076;
            --bg-color: #fff5f5;
            --text-color: #333;
            --border-radius: 12px;
            --box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        .app-title {
            color: var(--primary-color);
            margin-bottom: 10px;
            font-weight: bold;
            font-size: 2.2rem;
        }

        .app-version {
            font-size: 0.8rem;
            color: #666;
            margin-bottom: 10px;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: var(--box-shadow);
        }

        .tab {
            flex: 1;
            padding: 15px;
            text-align: center;
            background-color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
        }

        .tab.active {
            border-bottom: 3px solid var(--primary-color);
            font-weight: bold;
        }

        .tab:hover {
            background-color: #f9f9f9;
        }

        .tab-content {
            display: none;
            background: white;
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            animation: fadeIn 0.5s;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .cycle-status {
            text-align: center;
            margin-bottom: 30px;
            padding: 15px;
            border-radius: var(--border-radius);
            background-color: white;
            box-shadow: var(--box-shadow);
        }

        .cycle-wheel {
            width: 220px;
            height: 220px;
            border-radius: 50%;
            margin: 0 auto 20px;
            position: relative;
            background-color: #f1f1f1;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .cycle-ring {
            position: absolute;
            width: 220px;
            height: 220px;
            border-radius: 50%;
            border: 30px solid #e0e0e0;
        }

        .cycle-segment {
            position: absolute;
            width: 220px;
            height: 220px;
            border-radius: 50%;
            clip: rect(0, 220px, 220px, 110px);
        }

        .cycle-segment-inner {
            position: absolute;
            width: 220px;
            height: 220px;
            border-radius: 50%;
            clip: rect(0, 110px, 220px, 0);
            transform: rotate(var(--rotation));
            border: 30px solid var(--segment-color);
        }

        .phase-indicator {
            width: 150px;
            height: 150px;
            background-color: white;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 10px;
            z-index: 2;
        }

        .phase-indicator h2 {
            color: var(--primary-color);
            font-size: 1.5rem;
            margin-bottom: 5px;
        }

        .phase-indicator p {
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .countdown {
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--primary-dark);
        }

        .prediction-info {
            background-color: #f9f9f9;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-top: 15px;
        }

        .button-container {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
            box-shadow: var(--box-shadow);
            white-space: nowrap;
        }

        button:hover {
            background-color: #ff5252;
        }

        button.secondary {
            background-color: #6c757d;
        }

        button.secondary:hover {
            background-color: #5a6268;
        }

        button.success {
            background-color: #28a745;
        }

        button.success:hover {
            background-color: #218838;
        }

        /* Daily Quest Grid */
        .daily-quest {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .quest-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
            margin-bottom: 15px;
        }

        .quest-header h3 {
            margin: 0;
        }

        .quest-date {
            font-weight: bold;
        }

        .quest-day {
            color: #666;
        }

        .quest-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            padding: 15px 10px;
            border-radius: var(--border-radius);
            transition: all 0.3s ease;
            background-color: #f8f8f8;
        }

        .quest-item:hover {
            transform: translateY(-3px);
            box-shadow: var(--box-shadow);
        }

        .quest-icon {
            font-size: 2rem;
            margin-bottom: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background-color: white;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .icon-period {
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
        }

        .icon-temperature {
            color: #ff9500;
            border: 2px solid #ff9500;
        }

        .icon-mucus {
            color: #00b4d8;
            border: 2px solid #00b4d8;
        }

        .icon-cervix {
            color: #9d4edd;
            border: 2px solid #9d4edd;
        }

        .icon-intercourse {
            color: #ff66c4;
            border: 2px solid #ff66c4;
        }

        .icon-supplements {
            color: #0ead69;
            border: 2px solid #0ead69;
        }

        .icon-meds {
            color: #ff7b00;
            border: 2px solid #ff7b00;
        }

        .icon-mood {
            color: #4361ee;
            border: 2px solid #4361ee;
        }

        .icon-pain {
            color: #ef476f;
            border: 2px solid #ef476f;
        }

        .icon-weight {
            color: #118ab2;
            border: 2px solid #118ab2;
        }

        .icon-notes {
            color: #073b4c;
            border: 2px solid #073b4c;
        }

        .icon-breast {
            color: #ff758f;
            border: 2px solid #ff758f;
        }

        .icon-settings {
            color: #6c757d;
            border: 2px solid #6c757d;
        }

        .icon-add {
            color: #28a745;
            border: 2px solid #28a745;
        }

        .icon-custom {
            color: #9c27b0;
            border: 2px solid #9c27b0;
        }

        .quest-label {
            font-size: 0.85rem;
        }

        .form-dialog {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s;
        }

        .dialog-content {
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            padding: 20px;
        }

        .dialog-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .dialog-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin: 0;
        }

        .dialog-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            padding: 0;
            box-shadow: none;
        }

        .dialog-close:hover {
            color: #333;
        }

        form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: bold;
        }

        .radio-group {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        input[type="date"],
        textarea,
        input[type="number"],
        input[type="time"],
        input[type="text"] {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        select {
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #ddd;
            background-color: white;
        }

        .symptom-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .symptom-option {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .calendar {
            margin-top: 20px;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .calendar-title {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .calendar-tools {
            display: flex;
            gap: 10px;
        }

        .calendar-tool {
            font-size: 1.2rem;
            background: none;
            border: none;
            cursor: pointer;
            color: #666;
            padding: 5px;
            box-shadow: none;
        }

        .calendar-tool:hover {
            color: var(--primary-color);
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: #f9f9f9;
            border-radius: 8px;
            font-size: 0.9rem;
            position: relative;
            cursor: pointer;
            padding: 5px;
            min-height: 40px;
        }

        .calendar-day:hover {
            background-color: #f1f1f1;
        }

        .calendar-day.period {
            background-color: var(--primary-color);
            color: white;
        }

        .calendar-day.fertile {
            background-color: var(--tertiary-color);
        }

        .calendar-day.ovulation {
            background-color: var(--secondary-color);
            color: white;
        }

        .calendar-day-header {
            text-align: center;
            font-weight: bold;
            padding: 5px 0;
        }

        .day-indicator {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 6px;
            height: 6px;
            border-radius: 50%;
        }

        .day-symbol {
            font-size: 0.7rem;
            margin-top: 2px;
        }

        .symptom-indicator {
            background-color: #6c63ff;
        }

        .stats-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .stat-card {
            background-color: white;
            padding: 15px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
        }

        .stat-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: var(--primary-color);
        }

        .data-management {
            margin-top: 20px;
        }

        .error-message {
            color: red;
            margin-top: 5px;
            font-size: 0.9rem;
        }

        .success-message {
            color: green;
            margin-top: 5px;
            font-size: 0.9rem;
        }

        .hidden {
            display: none;
        }

        .notification-banner {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: var(--border-radius);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .notification-banner button {
            background-color: transparent;
            color: #856404;
            border: 1px solid #856404;
            padding: 5px 10px;
            font-size: 0.8rem;
            box-shadow: none;
        }

        .notification-banner button:hover {
            background-color: #856404;
            color: white;
        }

        .backup-card {
            background-color: white;
            padding: 20px;
            border-radius: var(--border-radius);
            margin-top: 20px;
            box-shadow: var(--box-shadow);
        }

        .backup-history {
            margin-top: 15px;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #f0f0f0;
            border-radius: 8px;
            padding: 10px;
        }

        .backup-item {
            padding: 10px;
            border-bottom: 1px solid #f0f0f0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .backup-item:last-child {
            border-bottom: none;
        }

        .backup-date {
            font-weight: bold;
        }

        .backup-item button {
            padding: 5px 10px;
            font-size: 0.8rem;
        }

        .tab-content-section {
            margin-bottom: 25px;
            border-bottom: 1px solid #f0f0f0;
            padding-bottom: 25px;
        }

        .tab-content-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .section-title {
            font-size: 1.2rem;
            margin-bottom: 15px;
            color: var(--primary-color);
        }

        .switch-container {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            margin-right: 10px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        /* Chart styles */
        .chart-container {
            height: 300px;
            margin: 20px 0;
            position: relative;
        }

        .export-options {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .badge {
            display: inline-block;
            padding: 3px 8px;
            font-size: 0.8em;
            font-weight: bold;
            border-radius: 10px;
            background-color: #e9ecef;
            color: #495057;
            margin-left: 5px;
        }

        .badge-auto {
            background-color: #17a2b8;
            color: white;
        }

        .badge-manual {
            background-color: #6c757d;
            color: white;
        }

        .info-text {
            margin-top: 10px;
            font-size: 0.9em;
            color: #6c757d;
        }

        .table-container {
            overflow-x: auto;
            margin-top: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        table th, table td {
            padding: 8px 12px;
            text-align: left;
            border-bottom: 1px solid #dee2e6;
        }

        table th {
            background-color: #f8f9fa;
        }

        .pagination {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }

        .pagination button {
            padding: 5px 10px;
        }

        /* Benutzerdefinierte Parameter Styles */
        .custom-parameters-container {
            margin-top: 20px;
        }

        .custom-parameter-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border-left: 4px solid #9c27b0;
        }

        .custom-parameter-name {
            font-weight: bold;
        }

        .custom-parameter-type {
            color: #666;
            font-size: 0.9em;
        }

        .custom-parameter-actions {
            display: flex;
            gap: 5px;
        }

        .custom-parameter-actions button {
            padding: 5px 10px;
            font-size: 0.8rem;
        }

        .parameter-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            margin-bottom: 5px;
            background-color: #f1f1f1;
            border-radius: 5px;
        }

        .parameter-option button {
            padding: 2px 8px;
            font-size: 0.7rem;
        }

        .option-list {
            margin-top: 10px;
            max-height: 200px;
            overflow-y: auto;
            padding: 5px;
            border: 1px solid #eee;
            border-radius: 5px;
        }

        .icon-selector {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .icon-option {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: #f8f8f8;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .icon-option:hover,
        .icon-option.selected {
            background-color: #e0e0e0;
        }

        .color-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .color-option:hover,
        .color-option.selected {
            transform: scale(1.2);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        /* Drag-Handle f√ºr Sortieren */
        .drag-handle {
            cursor: move;
            color: #999;
            font-size: 1.2em;
            margin-right: 10px;
        }

        /* Mobile Anpassungen */
        @media (max-width: 600px) {
            .daily-quest {
                grid-template-columns: repeat(2, 1fr);
            }

            .symptom-grid {
                grid-template-columns: 1fr;
            }

            .stats-container {
                grid-template-columns: 1fr;
            }

            .button-container {
                flex-direction: column;
                align-items: center;
            }

            button {
                width: 100%;
            }

            .export-options {
                flex-direction: column;
            }

            .icon-selector {
                grid-template-columns: repeat(6, 1fr);
            }
        }
    </style>
</head>
<body>
    <header>
        <h1 class="app-title">MeinZyklus</h1>
        <div class="app-version">Version 1.4.0</div>
        <p>Zyklustracking-App mit s√º√üem Design und starken Funktionen</p>
    </header>

    <div id="notificationBanner" class="notification-banner hidden">
        <span id="notificationText">Benachrichtigung</span>
        <button id="notificationClose">Schlie√üen</button>
    </div>

    <div class="cycle-status">
        <div class="cycle-wheel" id="cycleWheel">
            <div class="cycle-ring" id="cycleRing"></div>
            <div class="phase-indicator" id="phaseIndicator">
                <h2 id="cycleDay">Tag --</h2>
                <p id="cyclePhase">--</p>
                <div class="countdown">
                    <span id="nextPeriod">--</span> Tage bis zur n√§chsten Periode
                </div>
            </div>
        </div>
    </div>

    <div class="tabs">
        <div class="tab active" data-tab="heute">Heute</div>
        <div class="tab" data-tab="kalender">Kalender</div>
        <div class="tab" data-tab="statistik">Statistik</div>
        <div class="tab" data-tab="einstellungen">Einstellungen</div>
    </div>

    <div class="tab-content active" id="heute">
        <div class="quest-header">
            <div>
                <h3>T√§gliche Quest</h3>
                <div>
                    <span class="quest-date" id="questDate">22. M√§rz 2025</span>
                    <span class="quest-day" id="questDay">Samstag</span>
                </div>
            </div>
            <button id="prevDay">‚Üê</button>
            <button id="nextDay">‚Üí</button>
        </div>

        <div class="daily-quest" id="dailyQuestContainer">
            <div class="quest-item" data-type="period">
                <div class="quest-icon icon-period">ü©∏</div>
                <div class="quest-label">Menstruation</div>
            </div>
            <div class="quest-item" data-type="temperature">
                <div class="quest-icon icon-temperature">üå°Ô∏è</div>
                <div class="quest-label">Temperatur</div>
            </div>
            <div class="quest-item" data-type="mucus">
                <div class="quest-icon icon-mucus">üíß</div>
                <div class="quest-label">Schleim</div>
            </div>
            <div class="quest-item" data-type="cervix">
                <div class="quest-icon icon-cervix">‚≠ï</div>
                <div class="quest-label">Geb√§rmutterhals</div>
            </div>
            <div class="quest-item" data-type="intercourse">
                <div class="quest-icon icon-intercourse">üíú</div>
                <div class="quest-label">Geschlechtsv.</div>
            </div>
            <div class="quest-item" data-type="supplements">
                <div class="quest-icon icon-supplements">üåø</div>
                <div class="quest-label">Nahrungserg.</div>
            </div>
            <div class="quest-item" data-type="medication">
                <div class="quest-icon icon-meds">üíä</div>
                <div class="quest-label">Medikamente</div>
            </div>
            <div class="quest-item" data-type="mood">
                <div class="quest-icon icon-mood">üòä</div>
                <div class="quest-label">Stimmung</div>
            </div>
            <div class="quest-item" data-type="pain">
                <div class="quest-icon icon-pain">ü§ï</div>
                <div class="quest-label">Kopfschmerzen</div>
            </div>
            <div class="quest-item" data-type="weight">
                <div class="quest-icon icon-weight">‚öñÔ∏è</div>
                <div class="quest-label">Gewicht</div>
            </div>
            <div class="quest-item" data-type="notes">
                <div class="quest-icon icon-notes">üìù</div>
                <div class="quest-label">Notizen</div>
            </div>
            <div class="quest-item" data-type="breast">
                <div class="quest-icon icon-breast">üëö</div>
                <div class="quest-label">Brustgef√ºhl</div>
            </div>
            <!-- Neue Quest-Items f√ºr benutzerdefinierte Parameter werden per JavaScript hinzugef√ºgt -->
        </div>
    </div>

    <div class="tab-content" id="kalender">
        <div class="calendar-header">
            <div class="calendar-title">
                <button id="prevMonth">‚Üê</button>
                <h3 id="currentMonth">M√§rz 2025</h3>
                <button id="nextMonth">‚Üí</button>
            </div>
            <div class="calendar-tools">
                <button class="calendar-tool" id="calendarSearch">üîç</button>
                <button class="calendar-tool" id="calendarSettings">‚öôÔ∏è</button>
            </div>
        </div>
        <div class="calendar-day-header">
            <div class="calendar-grid">
                <div>Mo</div>
                <div>Di</div>
                <div>Mi</div>
                <div>Do</div>
                <div>Fr</div>
                <div>Sa</div>
                <div>So</div>
            </div>
        </div>
        <div class="calendar-grid" id="calendarGrid">
            <!-- Kalendertage werden per JavaScript eingef√ºgt -->
        </div>

        <div style="margin-top: 15px;">
            <h4>Legende:</h4>
            <div style="display: flex; flex-wrap: wrap; gap: 15px; margin-top: 10px;">
                <div style="display: flex; align-items: center;">
                    <span style="color: var(--primary-color); margin-right: 5px;">ü©∏‚ÇÅ</span>
                    <span>Spotting</span>
                </div>
                <div style="display: flex; align-items: center;">
                    <span style="color: var(--primary-color); margin-right: 5px;">ü©∏‚ÇÇ</span>
                    <span>Leicht</span>
                </div>
                <div style="display: flex; align-items: center;">
                    <span style="color: var(--primary-color); margin-right: 5px;">ü©∏‚ÇÉ</span>
                    <span>Mittel</span>
                </div>
                <div style="display: flex; align-items: center;">
                    <span style="color: var(--primary-color); margin-right: 5px;">ü©∏‚ÇÑ</span>
                    <span>Stark</span>
                </div>
                <div style="display: flex; align-items: center;">
                    <span style="color: var(--tertiary-color); margin-right: 5px;">üü†</span>
                    <span>Fruchtbare Tage</span>
                </div>
                <div style="display: flex; align-items: center;">
                    <span style="margin-right: 5px;">üåº</span>
                    <span>Eisprung</span>
                </div>
                <div style="display: flex; align-items: center;">
                    <span style="margin-right: 5px;">üåô</span>
                    <span>Mondphase</span>
                </div>
                <div style="display: flex; align-items: center;">
                    <span style="color: #ff66c4; margin-right: 5px;">üíú</span>
                    <span>Geschlechtsverkehr</span>
                </div>
            </div>
        </div>
    </div>

    <div class="tab-content" id="statistik">
        <h2>Zyklusstatistik</h2>
        <div class="stats-container">
            <div class="stat-card">
                <div class="stat-title">Durchschnittliche Zyklusl√§nge</div>
                <div id="avgCycleLength">-- Tage</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">Durchschnittliche Periodenl√§nge</div>
                <div id="avgPeriodLength">-- Tage</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">H√§ufigste Symptome</div>
                <div id="topSymptoms">--</div>
            </div>
            <div class="stat-card">
                <div class="stat-title">Letzte Zyklen</div>
                <div id="recentCycles">--</div>
            </div>
        </div>

        <div id="customParametersStats">
            <!-- Hier werden die Statistiken f√ºr benutzerdefinierte Parameter eingef√ºgt -->
        </div>

        <div class="table-container">
            <h3 class="section-title">Eintrags√ºbersicht</h3>
            <table id="entriesTable">
                <thead>
                    <tr>
                        <th>Datum</th>
                        <th>Periode</th>
                        <th>Temperatur</th>
                        <th>Symptome</th>
                        <th>Benutzerdefiniert</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Tabellendaten werden per JavaScript eingef√ºgt -->
                </tbody>
            </table>
            <div class="pagination" id="entriesPagination">
                <!-- Paginierung wird per JavaScript eingef√ºgt -->
            </div>
        </div>
    </div>

    <div class="tab-content" id="einstellungen">
        <h2>Einstellungen & Daten</h2>

        <!-- Neuer Abschnitt f√ºr benutzerdefinierte Parameter -->
        <div class="tab-content-section">
            <h3 class="section-title">Benutzerdefinierte Parameter</h3>
            <p>Erstelle eigene Parameter, die du t√§glich tracken m√∂chtest:</p>

            <div class="custom-parameters-container" id="customParametersContainer">
                <!-- Hier werden die benutzerdefinierten Parameter angezeigt -->
                <div class="info-text" id="noCustomParametersInfo">Keine benutzerdefinierten Parameter vorhanden. Klicke auf 'Neuer Parameter', um einen zu erstellen.</div>
            </div>

            <div class="button-container">
                <button id="newCustomParameter">Neuer Parameter</button>
            </div>
        </div>

        <div class="tab-content-section">
            <h3 class="section-title">Automatisches Backup</h3>
            <div class="switch-container">
                <label class="switch">
                    <input type="checkbox" id="autoBackupEnabled" checked>
                    <span class="slider"></span>
                </label>
                <span>Automatisches Backup aktivieren</span>
            </div>

            <div class="form-group">
                <label>Backup-Intervall (in Tagen):</label>
                <input type="number" id="backupInterval" min="1" max="90" value="7">
            </div>

            <div class="form-group">
                <label>Maximale Anzahl von Backups:</label>
                <input type="number" id="maxBackupsCount" min="5" max="100" value="30">
                <p class="info-text">H√∂here Werte erm√∂glichen mehr Historie, nutzen aber mehr Speicherplatz.</p>
            </div>
        </div>

        <div class="tab-content-section">
            <h3 class="section-title">Backup-Historie</h3>
            <div class="backup-history" id="backupHistory">
                <!-- Backup-Historie wird per JavaScript eingef√ºgt -->
                <div class="backup-item">
                    <span class="backup-date">Keine Backups vorhanden</span>
                </div>
            </div>
            <div class="button-container">
                <button id="createBackup">Manuelles Backup erstellen</button>
            </div>
        </div>

        <div class="tab-content-section">
            <h3 class="section-title">Datenexport</h3>
            <p>Exportiere deine Daten f√ºr externe Sicherung oder √úbertragung auf ein anderes Ger√§t:</p>
            <div class="export-options">
                <button id="exportDataJson">Als JSON exportieren</button>
                <button id="exportDataCsv">Als CSV exportieren</button>
            </div>
        </div>

        <div class="tab-content-section">
            <h3 class="section-title">Datenimport</h3>
            <p>Lade eine zuvor exportierte Datei (JSON oder CSV):</p>
            <div class="form-group">
                <input type="file" id="importFile" accept=".json,.csv">
                <div class="button-container">
                    <button id="importData">Daten importieren</button>
                </div>
                <div id="importMessage" class="hidden"></div>
            </div>
            <p class="info-text">
                <strong>Hinweis:</strong> Browser k√∂nnen aus Sicherheitsgr√ºnden nicht direkt auf den "Zykli"-Ordner
                zugreifen. Bitte navigiere manuell zu diesem Ordner, wenn du die Dateiauswahl √∂ffnest.
            </p>
        </div>

        <div class="tab-content-section">
            <h3 class="section-title">Daten zur√ºcksetzen</h3>
            <p>Vorsicht: Diese Aktion kann nicht r√ºckg√§ngig gemacht werden!</p>
            <div class="button-container">
                <button id="resetData">Alle Daten l√∂schen</button>
            </div>
        </div>
    </div>

    <!-- Eingabeformular-Dialog -->
    <div class="form-dialog" id="entryDialog">
        <div class="dialog-content">
            <div class="dialog-header">
                <h3 class="dialog-title" id="dialogTitle">Eintrag bearbeiten</h3>
                <button class="dialog-close" id="dialogClose">&times;</button>
            </div>
            <form id="dailyEntryForm">
                <div class="form-group">
                    <label>Datum:</label>
                    <input type="date" id="entryDate" required>
                </div>

                <div class="form-group">
                    <label>Periode:</label>
                    <div class="radio-group">
                        <div class="radio-option">
                            <input type="radio" name="flow" id="flow-none" value="NONE" checked>
                            <label for="flow-none">Keine</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" name="flow" id="flow-spotting" value="SPOTTING">
                            <label for="flow-spotting">Spotting</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" name="flow" id="flow-light" value="LIGHT">
                            <label for="flow-light">Leicht</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" name="flow" id="flow-medium" value="MEDIUM">
                            <label for="flow-medium">Mittel</label>
                        </div>
                        <div class="radio-option">
                            <input type="radio" name="flow" id="flow-heavy" value="HEAVY">
                            <label for="flow-heavy">Stark</label>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Basaltemperatur (optional):</label>
                    <input type="number" id="temperature" step="0.1" min="35" max="40" placeholder="z.B. 36.5">
                </div>

                <div class="form-group">
                    <label>Zervixschleim:</label>
                    <select id="cervicalMucus">
                        <option value="">Nicht eingetragen</option>
                        <option value="DRY">Trocken</option>
                        <option value="STICKY">Klebrig</option>
                        <option value="CREAMY">Cremig</option>
                        <option value="WATERY">W√§ssrig</option>
                        <option value="EGG_WHITE">Spinnbar (Eiwei√üklar)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Brustgef√ºhl:</label>
                    <select id="breastFeeling">
                        <option value="">Nicht eingetragen</option>
                        <option value="NONE">Keine Beschwerden</option>
                        <option value="SENSITIVE">Empfindlich</option>
                        <option value="TENSE">Spannt</option>
                        <option value="PAINFUL">Schmerzt</option>
                        <option value="VERY_PAINFUL">Sehr schmerzhaft</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Symptome:</label>
                    <div class="symptom-grid">
                        <div class="symptom-option">
                            <input type="checkbox" id="symptom-headache" name="symptoms" value="HEADACHE">
                            <label for="symptom-headache">Kopfschmerzen</label>
                        </div>
                        <div class="symptom-option">
                            <input type="checkbox" id="symptom-cramps" name="symptoms" value="CRAMPS">
                            <label for="symptom-cramps">Kr√§mpfe</label>
                        </div>
                        <div class="symptom-option">
                            <input type="checkbox" id="symptom-backache" name="symptoms" value="BACKACHE">
                            <label for="symptom-backache">R√ºckenschmerzen</label>
                        </div>
                        <div class="symptom-option">
                            <input type="checkbox" id="symptom-fatigue" name="symptoms" value="FATIGUE">
                            <label for="symptom-fatigue">M√ºdigkeit</label>
                        </div>
                        <div class="symptom-option">
                            <input type="checkbox" id="symptom-bloating" name="symptoms" value="BLOATING">
                            <label for="symptom-bloating">Bl√§hungen</label>
                        </div>
                        <div class="symptom-option">
                            <input type="checkbox" id="symptom-mood" name="symptoms" value="MOOD">
                            <label for="symptom-mood">Stimmungsschwankungen</label>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Notizen:</label>
                    <textarea id="notes" rows="3" placeholder="Notizen zum Tag..."></textarea>
                </div>

                <!-- Hier werden die benutzerdefinierten Parameter-Felder eingef√ºgt -->
                <div id="customParameterFields"></div>

                <div class="button-container">
                    <button type="submit">Eintrag speichern</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Dialog f√ºr neue benutzerdefinierte Parameter -->
    <div class="form-dialog" id="customParameterDialog">
        <div class="dialog-content">
            <div class="dialog-header">
                <h3 class="dialog-title" id="parameterDialogTitle">Neuer Parameter</h3>
                <button class="dialog-close" id="parameterDialogClose">&times;</button>
            </div>
            <form id="customParameterForm">
                <div class="form-group">
                    <label>Name des Parameters:</label>
                    <input type="text" id="parameterName" placeholder="z.B. Schlafqualit√§t" required>
                </div>

                <div class="form-group">
                    <label>Symbol:</label>
                    <div class="icon-selector" id="iconSelector">
                        <div class="icon-option" data-icon="üò¥">üò¥</div>
                        <div class="icon-option" data-icon="üß†">üß†</div>
                        <div class="icon-option" data-icon="üí§">üí§</div>
                        <div class="icon-option" data-icon="üèÉ‚Äç‚ôÄÔ∏è">üèÉ‚Äç‚ôÄÔ∏è</div>
                        <div class="icon-option" data-icon="üö∂‚Äç‚ôÄÔ∏è">üö∂‚Äç‚ôÄÔ∏è</div>
                        <div class="icon-option" data-icon="üí™">üí™</div>
                        <div class="icon-option" data-icon="üßò‚Äç‚ôÄÔ∏è">üßò‚Äç‚ôÄÔ∏è</div>
                        <div class="icon-option" data-icon="ü•ó">ü•ó</div>
                        <div class="icon-option" data-icon="üçé">üçé</div>
                        <div class="icon-option" data-icon="üíß">üíß</div>
                        <div class="icon-option" data-icon="üåø">üåø</div>
                        <div class="icon-option" data-icon="üíä">üíä</div>
                        <div class="icon-option" data-icon="ü©π">ü©π</div>
                        <div class="icon-option" data-icon="üß™">üß™</div>
                        <div class="icon-option" data-icon="üå°Ô∏è">üå°Ô∏è</div>
                        <div class="icon-option" data-icon="üì±">üì±</div>
                        <div class="icon-option" data-icon="üìà">üìà</div>
                        <div class="icon-option" data-icon="üìâ">üìâ</div>
                        <div class="icon-option" data-icon="üìä">üìä</div>
                        <div class="icon-option" data-icon="üåû">üåû</div>
                        <div class="icon-option" data-icon="üåô">üåô</div>
                        <div class="icon-option" data-icon="‚≠ê">‚≠ê</div>
                        <div class="icon-option" data-icon="üìù">üìù</div>
                        <div class="icon-option" data-icon="üíØ">üíØ</div>
                    </div>
                    <input type="hidden" id="selectedIcon" value="‚≠ê" required>
                </div>

                <div class="form-group">
                    <label>Farbe:</label>
                    <div class="color-selector" id="colorSelector">
                        <div class="color-option" style="background-color: #e53935;" data-color="#e53935"></div>
                        <div class="color-option" style="background-color: #d81b60;" data-color="#d81b60"></div>
                        <div class="color-option" style="background-color: #8e24aa;" data-color="#8e24aa"></div>
                        <div class="color-option" style="background-color: #5e35b1;" data-color="#5e35b1"></div>
                        <div class="color-option" style="background-color: #3949ab;" data-color="#3949ab"></div>
                        <div class="color-option" style="background-color: #1e88e5;" data-color="#1e88e5"></div>
                        <div class="color-option" style="background-color: #039be5;" data-color="#039be5"></div>
                        <div class="color-option" style="background-color: #00acc1;" data-color="#00acc1"></div>
                        <div class="color-option" style="background-color: #00897b;" data-color="#00897b"></div>
                        <div class="color-option" style="background-color: #43a047;" data-color="#43a047"></div>
                        <div class="color-option" style="background-color: #7cb342;" data-color="#7cb342"></div>
                        <div class="color-option selected" style="background-color: #c0ca33;" data-color="#c0ca33"></div>
                        <div class="color-option" style="background-color: #fdd835;" data-color="#fdd835"></div>
                        <div class="color-option" style="background-color: #ffb300;" data-color="#ffb300"></div>
                        <div class="color-option" style="background-color: #fb8c00;" data-color="#fb8c00"></div>
                        <div class="color-option" style="background-color: #f4511e;" data-color="#f4511e"></div>
                        <div class="color-option" style="background-color: #6d4c41;" data-color="#6d4c41"></div>
                        <div class="color-option" style="background-color: #757575;" data-color="#757575"></div>
                        <div class="color-option" style="background-color: #546e7a;" data-color="#546e7a"></div>
                        <div class="color-option" style="background-color: #9c27b0;" data-color="#9c27b0"></div>
                    </div>
                    <input type="hidden" id="selectedColor" value="#c0ca33" required>
                </div>

                <div class="form-group">
                    <label>Typ des Parameters:</label>
                    <select id="parameterType" required>
                        <option value="">-- Bitte w√§hlen --</option>
                        <option value="boolean">Ja/Nein</option>
                        <option value="text">Textfeld</option>
                        <option value="number">Zahlenwert</option>
                        <option value="select">Auswahl (mehrere Optionen)</option>
                    </select>
                </div>

                <!-- Zus√§tzliche Felder f√ºr numerische Parameter -->
                <div class="form-group" id="numberOptionsContainer" style="display: none;">
                    <label>Einheit (optional):</label>
                    <input type="text" id="parameterUnit" placeholder="z.B. Stunden, kg, ml">
                    <div class="form-group">
                        <label>Minimalwert:</label>
                        <input type="number" id="parameterMinValue" step="any" value="0">
                    </div>
                    <div class="form-group">
                        <label>Maximalwert:</label>
                        <input type="number" id="parameterMaxValue" step="any" value="100">
                    </div>
                </div>

                <!-- Zus√§tzliche Felder f√ºr Auswahlparameter -->
                <div id="selectOptionsContainer" style="display: none;">
                    <div class="form-group">
                        <label>Optionen:</label>
                        <div class="option-list" id="optionList">
                            <!-- Option-Elemente werden hier hinzugef√ºgt -->
                        </div>
                        <div style="display: flex; margin-top: 10px; gap: 10px;">
                            <input type="text" id="newOptionText" placeholder="Neue Option eingeben" style="flex: 1;">
                            <button type="button" id="addOption" class="secondary">Hinzuf√ºgen</button>
                        </div>
                    </div>
                </div>

                <div class="button-container">
                    <button type="submit">Parameter speichern</button>
                </div>
            </form>
        </div>
    </div>

    <script>
        // Datenmodell und Speicherung
        const STORAGE_KEY = 'cycleTackingApp';
        const BACKUP_STORAGE_KEY = 'cycleTrackingAppBackups';
        const APP_VERSION = '1.4.0';

        // Initialisiere leeres Datenmodell
        let appData = {
            cycles: [],
            entries: [],
            settings: {
                cycleLength: 28, // Standardwert f√ºr Zyklusl√§nge
                periodLength: 5, // Standardwert f√ºr Periodenl√§nge
                autoBackup: {
                    enabled: true,
                    interval: 7, // Backup alle 7 Tage
                    lastBackup: null,
                    maxBackups: 30  // Maximal 30 Backups
                }
            },
            // Neue Eigenschaft f√ºr benutzerdefinierte Parameter
            customParameters: [],
            version: APP_VERSION
        };

        // Backup-Historie
        let backupHistory = [];

        // Aktuelles Datum f√ºr die t√§gliche Quest
        let currentQuestDate = new Date();

        // Variable f√ºr den aktuell bearbeiteten Parameter
        let currentEditingParameter = null;

        // Lade gespeicherte Daten
        function loadData() {
            const savedData = localStorage.getItem(STORAGE_KEY);
            if (savedData) {
                try {
                    appData = JSON.parse(savedData);

                    // Stelle sicher, dass die Backup-Einstellungen existieren und vollst√§ndig sind
                    if (!appData.settings.autoBackup) {
                        appData.settings.autoBackup = {
                            enabled: true,
                            interval: 7,
                            lastBackup: null,
                            maxBackups: 30
                        };
                    } else if (!appData.settings.autoBackup.maxBackups) {
                        appData.settings.autoBackup.maxBackups = 30;
                    }

                    // Stelle sicher, dass das customParameters-Array existiert
                    if (!appData.customParameters) {
                        appData.customParameters = [];
                    }

                    // F√ºge Versionsinformation hinzu, falls nicht vorhanden
                    if (!appData.version) {
                        appData.version = APP_VERSION;
                    }

                    // Pr√ºfe, ob ein App-Update stattgefunden hat
                    if (appData.version !== APP_VERSION) {
                        // Update-Benachrichtigung
                        showNotification(`Die App wurde auf Version ${APP_VERSION} aktualisiert. Neue Funktionen: Benutzerdefinierte Parameter!`, 'info');
                        appData.version = APP_VERSION;
                        saveData();
                    }
                } catch (error) {
                    console.error('Fehler beim Laden der Daten:', error);
                    showNotification('Fehler beim Laden der Daten. Die App wurde zur√ºckgesetzt.', 'error');
                }
            }

            // Lade Backup-Historie
            const savedBackups = localStorage.getItem(BACKUP_STORAGE_KEY);
            if (savedBackups) {
                try {
                    backupHistory = JSON.parse(savedBackups);
                } catch (error) {
                    console.error('Fehler beim Laden der Backup-Historie:', error);
                    backupHistory = [];
                }
            }
        }

        // Speichere Daten im localStorage
        function saveData() {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(appData));

            // Pr√ºfe, ob ein automatisches Backup f√§llig ist
            checkAutoBackup();
        }

        // Speichere Backup-Historie
        function saveBackupHistory() {
            localStorage.setItem(BACKUP_STORAGE_KEY, JSON.stringify(backupHistory));
        }

        // Pr√ºfe, ob ein automatisches Backup erstellt werden soll
        function checkAutoBackup() {
            if (!appData.settings.autoBackup.enabled) {
                return;
            }

            const now = new Date();
            const lastBackup = appData.settings.autoBackup.lastBackup ? new Date(appData.settings.autoBackup.lastBackup) : null;

            // Wenn noch kein Backup erstellt wurde oder das letzte Backup √§lter als das Intervall ist
            if (!lastBackup || (now - lastBackup) >= (appData.settings.autoBackup.interval * 24 * 60 * 60 * 1000)) {
                createBackup(true);
            }
        }

        // Erstelle ein Backup
        function createBackup(isAuto = false) {
            const now = new Date();
            const backupId = `backup_${now.getTime()}`;
            const backupData = JSON.stringify(appData);

            // Speichere das Backup im localStorage
            try {
                localStorage.setItem(backupId, backupData);

                // Aktualisiere das Datum des letzten Backups
                appData.settings.autoBackup.lastBackup = now.toISOString();
                saveData();

                // F√ºge das Backup zur Historie hinzu
                backupHistory.unshift({
                    id: backupId,
                    date: now.toISOString(),
                    isAuto: isAuto
                });

                // Begrenze die Anzahl der Backups auf die max. Anzahl
                const maxBackups = appData.settings.autoBackup.maxBackups || 30;
                if (backupHistory.length > maxBackups) {
                    const oldestBackups = backupHistory.splice(maxBackups);
                    oldestBackups.forEach(backup => {
                        localStorage.removeItem(backup.id);
                    });
                }

                saveBackupHistory();
                updateBackupHistory();

                if (!isAuto) {
                    showNotification('Backup erfolgreich erstellt!', 'success');
                }
            } catch (error) {
                console.error('Fehler beim Erstellen des Backups:', error);

                // Pr√ºfe, ob der Fehler auf einen vollen localStorage zur√ºckzuf√ºhren ist
                if (error.name === 'QuotaExceededError' || error.code === 22) {
                    showNotification('Der Speicherplatz ist voll. L√∂sche √§ltere Backups, um Platz zu schaffen.', 'error');

                    // L√∂sche das √§lteste Backup, wenn die Historie voll ist
                    if (backupHistory.length > 0) {
                        const oldestBackup = backupHistory.pop();
                        localStorage.removeItem(oldestBackup.id);
                        saveBackupHistory();
                        updateBackupHistory();

                        // Versuche es erneut
                        createBackup(isAuto);
                    }
                } else {
                    showNotification('Fehler beim Erstellen des Backups.', 'error');
                }
            }
        }

        // Backup wiederherstellen
        function restoreBackup(backupId) {
            try {
                const backupData = localStorage.getItem(backupId);

                if (backupData) {
                    appData = JSON.parse(backupData);

                    // Stelle sicher, dass Backup-Einstellungen vorhanden sind
                    if (!appData.settings.autoBackup) {
                        appData.settings.autoBackup = {
                            enabled: true,
                            interval: 7,
                            lastBackup: null,
                            maxBackups: 30
                        };
                    } else if (!appData.settings.autoBackup.maxBackups) {
                        appData.settings.autoBackup.maxBackups = 30;
                    }

                    // Stelle sicher, dass das customParameters-Array existiert
                    if (!appData.customParameters) {
                        appData.customParameters = [];
                    }

                    // Aktualisiere die Version
                    appData.version = APP_VERSION;

                    saveData();
                    updateUI();
                    showNotification('Backup erfolgreich wiederhergestellt!', 'success');
                } else {
                    showNotification('Backup nicht gefunden.', 'error');
                }
            } catch (error) {
                console.error('Fehler beim Wiederherstellen des Backups:', error);
                showNotification('Fehler beim Wiederherstellen des Backups.', 'error');
            }
        }

        // Backup l√∂schen
        function deleteBackup(backupId) {
            try {
                localStorage.removeItem(backupId);

                // Entferne das Backup aus der Historie
                backupHistory = backupHistory.filter(backup => backup.id !== backupId);
                saveBackupHistory();
                updateBackupHistory();

                showNotification('Backup erfolgreich gel√∂scht!', 'success');
            } catch (error) {
                console.error('Fehler beim L√∂schen des Backups:', error);
                showNotification('Fehler beim L√∂schen des Backups.', 'error');
            }
        }

        // Backup-Historie aktualisieren
        function updateBackupHistory() {
            const backupHistoryElement = document.getElementById('backupHistory');
            backupHistoryElement.innerHTML = '';

            if (backupHistory.length === 0) {
                const emptyItem = document.createElement('div');
                emptyItem.className = 'backup-item';
                emptyItem.innerHTML = '<span class="backup-date">Keine Backups vorhanden</span>';
                backupHistoryElement.appendChild(emptyItem);
                return;
            }

            backupHistory.forEach(backup => {
                const backupDate = new Date(backup.date);
                const formattedDate = backupDate.toLocaleDateString('de-DE', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });

                const backupItem = document.createElement('div');
                backupItem.className = 'backup-item';

                const badgeClass = backup.isAuto ? 'badge badge-auto' : 'badge badge-manual';
                const badgeText = backup.isAuto ? 'Auto' : 'Manuell';

                backupItem.innerHTML = `
                    <span class="backup-date">${formattedDate} <span class="${badgeClass}">${badgeText}</span></span>
                    <div>
                        <button class="restore-backup" data-id="${backup.id}">Wiederherstellen</button>
                        <button class="delete-backup" data-id="${backup.id}">L√∂schen</button>
                    </div>
                `;

                backupHistoryElement.appendChild(backupItem);
            });

            // Event-Listener f√ºr Backup-Aktionen
            document.querySelectorAll('.restore-backup').forEach(button => {
                button.addEventListener('click', () => {
                    const backupId = button.getAttribute('data-id');
                    if (confirm('M√∂chtest du dieses Backup wirklich wiederherstellen? Alle aktuellen Daten werden √ºberschrieben.')) {
                        restoreBackup(backupId);
                    }
                });
            });

            document.querySelectorAll('.delete-backup').forEach(button => {
                button.addEventListener('click', () => {
                    const backupId = button.getAttribute('data-id');
                    if (confirm('M√∂chtest du dieses Backup wirklich l√∂schen?')) {
                        deleteBackup(backupId);
                    }
                });
            });
        }

        // Daten als CSV exportieren
        function exportDataAsCsv() {
            // Sortiere Eintr√§ge nach Datum (neueste zuerst)
            const sortedEntries = [...appData.entries].sort((a, b) => {
                return new Date(b.date).getTime() - new Date(a.date).getTime();
            });

            // Sammle Header f√ºr benutzerdefinierte Parameter
            let customHeaders = appData.customParameters.map(param => param.name);

            // CSV-Header
            let csvContent = 'Datum,Periode,Temperatur,Zervixschleim,Brustgef√ºhl,Symptome,Notizen';

            // F√ºge benutzerdefinierte Parameter zu den Headern hinzu
            if (customHeaders.length > 0) {
                csvContent += ',' + customHeaders.join(',');
            }

            csvContent += '\n';

            // F√ºge Zeilen hinzu
            sortedEntries.forEach(entry => {
                // Periodenintensit√§t
                let flowText = '';
                switch (entry.flow) {
                    case 'NONE': flowText = 'Keine'; break;
                    case 'SPOTTING': flowText = 'Spotting'; break;
                    case 'LIGHT': flowText = 'Leicht'; break;
                    case 'MEDIUM': flowText = 'Mittel'; break;
                    case 'HEAVY': flowText = 'Stark'; break;
                    default: flowText = '';
                }

                // Zervixschleim
                let mucusText = '';
                switch (entry.cervicalMucus) {
                    case 'DRY': mucusText = 'Trocken'; break;
                    case 'STICKY': mucusText = 'Klebrig'; break;
                    case 'CREAMY': mucusText = 'Cremig'; break;
                    case 'WATERY': mucusText = 'W√§ssrig'; break;
                    case 'EGG_WHITE': mucusText = 'Spinnbar'; break;
                    default: mucusText = '';
                }

                // Brustgef√ºhl
                let breastText = '';
                switch (entry.breastFeeling) {
                    case 'NONE': breastText = 'Keine Beschwerden'; break;
                    case 'SENSITIVE': breastText = 'Empfindlich'; break;
                    case 'TENSE': breastText = 'Spannt'; break;
                    case 'PAINFUL': breastText = 'Schmerzt'; break;
                    case 'VERY_PAINFUL': breastText = 'Sehr schmerzhaft'; break;
                    default: breastText = '';
                }

                // Symptome
                const symptoms = entry.symptoms ? entry.symptoms.map(symptom => getSymptomName(symptom)).join(', ') : '';

                // Notizen (entferne Kommas und Zeilenumbr√ºche f√ºr CSV-Kompatibilit√§t)
                const notesText = entry.notes ? '"' + entry.notes.replace(/"/g, '""').replace(/\n/g, ' ') + '"' : '';

                // Benutzerdefinierte Parameter-Werte
                let customValues = [];

                if (entry.customParameters) {
                    appData.customParameters.forEach(param => {
                        const value = entry.customParameters[param.id] !== undefined ? entry.customParameters[param.id] : '';

                        // Formatiere den Wert je nach Parametertyp
                        let formattedValue = '';

                        if (value !== '') {
                            if (param.type === 'boolean') {
                                formattedValue = value ? 'Ja' : 'Nein';
                            } else if (param.type === 'number' && param.unit) {
                                formattedValue = `${value} ${param.unit}`;
                            } else if (param.type === 'select' && param.options) {
                                const option = param.options.find(opt => opt.value === value);
                                formattedValue = option ? option.text : value;
                            } else {
                                formattedValue = value;
                            }
                        }

                        // F√ºge Anf√ºhrungszeichen hinzu, wenn der Wert Kommas enth√§lt
                        if (typeof formattedValue === 'string' && formattedValue.includes(',')) {
                            formattedValue = `"${formattedValue.replace(/"/g, '""')}"`;
                        }

                        customValues.push(formattedValue);
                    });
                }

                // F√ºge Zeile hinzu
                csvContent += `${entry.date},${flowText},${entry.temperature || ''},${mucusText},${breastText},${symptoms},${notesText}`;

                // F√ºge benutzerdefinierte Parameter-Werte hinzu
                if (customValues.length > 0) {
                    csvContent += ',' + customValues.join(',');
                }

                csvContent += '\n';
            });

            // Erstelle Blob und Download-Link
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `Zykli_export_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('Daten erfolgreich als CSV exportiert!', 'success');
        }

        // Zeige eine Benachrichtigung
        function showNotification(message, type = 'info') {
            const banner = document.getElementById('notificationBanner');
            const text = document.getElementById('notificationText');

            text.textContent = message;

            // Setze die Farben je nach Typ
            if (type === 'error') {
                banner.style.backgroundColor = '#f8d7da';
                banner.style.borderColor = '#f5c6cb';
                banner.style.color = '#721c24';
            } else if (type === 'success') {
                banner.style.backgroundColor = '#d4edda';
                banner.style.borderColor = '#c3e6cb';
                banner.style.color = '#155724';
            } else {
                banner.style.backgroundColor = '#fff3cd';
                banner.style.borderColor = '#ffeeba';
                banner.style.color = '#856404';
            }

            banner.classList.remove('hidden');

            // Automatisch nach 5 Sekunden ausblenden
            setTimeout(() => {
                banner.classList.add('hidden');
            }, 5000);
        }

        // Tabs-Funktionalit√§t
        function setupTabs() {
            const tabs = document.querySelectorAll('.tab');
            tabs.forEach(tab => {
                tab.addEventListener('click', () => {
                    // Entferne aktive Klasse von allen Tabs
                    tabs.forEach(t => t.classList.remove('active'));
                    // F√ºge aktive Klasse zum geklickten Tab hinzu
                    tab.classList.add('active');

                    // Verstecke alle Tab-Inhalte
                    document.querySelectorAll('.tab-content').forEach(content => {
                        content.classList.remove('active');
                    });

                    // Zeige den entsprechenden Tab-Inhalt
                    const tabName = tab.getAttribute('data-tab');
                    document.getElementById(tabName).classList.add('active');

                    // Aktualisiere spezifische Inhalte f√ºr bestimmte Tabs
                    if (tabName === 'statistik') {
                        updateEntriesTable();
                        updateCustomParameterStats();
                    } else if (tabName === 'einstellungen') {
                        updateCustomParametersList();
                    }
                });
            });
        }

        // Dialog-Funktionalit√§t
        function setupDialog() {
            const dialog = document.getElementById('entryDialog');
            const closeBtn = document.getElementById('dialogClose');

            // Schlie√üen durch Klick auf X
            closeBtn.addEventListener('click', () => {
                dialog.style.display = 'none';
            });

            // Schlie√üen durch Klick au√üerhalb des Dialogs
            dialog.addEventListener('click', (event) => {
                if (event.target === dialog) {
                    dialog.style.display = 'none';
                }
            });

            // Event-Listener f√ºr die Formularabgabe
            document.getElementById('dailyEntryForm').addEventListener('submit', (event) => {
                event.preventDefault();

                // Sammle Formulardaten
                const date = document.getElementById('entryDate').value;
                const flow = document.querySelector('input[name="flow"]:checked').value;
                const temperature = document.getElementById('temperature').value ? parseFloat(document.getElementById('temperature').value) : null;
                const cervicalMucus = document.getElementById('cervicalMucus').value || null;
                const breastFeeling = document.getElementById('breastFeeling').value || null;

                // Sammle ausgew√§hlte Symptome
                const symptoms = [];
                document.querySelectorAll('input[name="symptoms"]:checked').forEach(checkbox => {
                    symptoms.push(checkbox.value);
                });

                const notes = document.getElementById('notes').value;

                // Sammle benutzerdefinierte Parameter-Werte
                const customParameters = {};

                appData.customParameters.forEach(param => {
                    const paramId = param.id;
                    let value = null;

                    if (param.type === 'boolean') {
                        const checkbox = document.getElementById(`param-${paramId}`);
                        if (checkbox) {
                            value = checkbox.checked;
                        }
                    } else if (param.type === 'number') {
                        const input = document.getElementById(`param-${paramId}`);
                        if (input && input.value) {
                            value = parseFloat(input.value);
                        }
                    } else if (param.type === 'text') {
                        const input = document.getElementById(`param-${paramId}`);
                        if (input) {
                            value = input.value;
                        }
                    } else if (param.type === 'select') {
                        const select = document.getElementById(`param-${paramId}`);
                        if (select) {
                            value = select.value;
                        }
                    }

                    if (value !== null) {
                        customParameters[paramId] = value;
                    }
                });

                // Erstelle den Eintrag
                const entry = {
                    date,
                    flow,
                    temperature,
                    cervicalMucus,
                    breastFeeling,
                    symptoms,
                    notes,
                    customParameters  // F√ºge benutzerdefinierte Parameter hinzu
                };

                // Pr√ºfe, ob bereits ein Eintrag f√ºr dieses Datum existiert
                const existingEntryIndex = appData.entries.findIndex(e => e.date === date);

                if (existingEntryIndex !== -1) {
                    // Aktualisiere den bestehenden Eintrag
                    appData.entries[existingEntryIndex] = { ...appData.entries[existingEntryIndex], ...entry };

                    // Pr√ºfe, ob ein Periodeneintrag hinzugef√ºgt oder entfernt wurde
                    if ((appData.entries[existingEntryIndex].flow === 'NONE' && flow !== 'NONE') ||
                        (appData.entries[existingEntryIndex].flow !== 'NONE' && flow === 'NONE')) {
                        // Neuberechnung der Zyklen k√∂nnte erforderlich sein
                        recalculateCycles();
                    }

                    saveData();
                } else {
                    // F√ºge einen neuen Eintrag hinzu
                    addEntry(entry);
                }

                showNotification('Eintrag gespeichert!', 'success');

                // Schlie√üe den Dialog
                dialog.style.display = 'none';

                // UI aktualisieren
                updateUI();
            });
        }

        // Tabellarische √úbersicht der Eintr√§ge
        function updateEntriesTable() {
            const tableBody = document.querySelector('#entriesTable tbody');
            tableBody.innerHTML = '';

            // Sortiere Eintr√§ge nach Datum (neueste zuerst)
            const sortedEntries = [...appData.entries].sort((a, b) => {
                return new Date(b.date).getTime() - new Date(a.date).getTime();
            });

            // Paginierung einrichten
            const itemsPerPage = 10;
            const totalPages = Math.ceil(sortedEntries.length / itemsPerPage);
            let currentPage = 1;

            function displayPage(page) {
                // Leere die Tabelle
                tableBody.innerHTML = '';

                // Berechne den Startindex
                const startIndex = (page - 1) * itemsPerPage;
                // Berechne den Endindex
                const endIndex = Math.min(startIndex + itemsPerPage, sortedEntries.length);

                // Zeige Eintr√§ge der aktuellen Seite
                for (let i = startIndex; i < endIndex; i++) {
                    const entry = sortedEntries[i];
                    const row = document.createElement('tr');

                    // Formatiere das Datum
                    const dateObj = new Date(entry.date);
                    const formattedDate = dateObj.toLocaleDateString('de-DE');

                    // Periodenintensit√§t
                    let flowText = '';
                    switch (entry.flow) {
                        case 'NONE': flowText = 'Keine'; break;
                        case 'SPOTTING': flowText = 'Spotting'; break;
                        case 'LIGHT': flowText = 'Leicht'; break;
                        case 'MEDIUM': flowText = 'Mittel'; break;
                        case 'HEAVY': flowText = 'Stark'; break;
                        default: flowText = '';
                    }

                    // Temperatur
                    const tempText = entry.temperature ? `${entry.temperature} ¬∞C` : '-';

                    // Symptome
                    const symptoms = entry.symptoms && entry.symptoms.length > 0
                        ? entry.symptoms.map(symptom => getSymptomName(symptom)).join(', ')
                        : '-';

                    // Benutzerdefinierte Parameter
                    let customParamsText = '-';

                    if (entry.customParameters && Object.keys(entry.customParameters).length > 0) {
                        const customParamValues = [];

                        Object.entries(entry.customParameters).forEach(([paramId, value]) => {
                            const parameter = appData.customParameters.find(p => p.id === paramId);

                            if (parameter) {
                                let formattedValue;

                                if (parameter.type === 'boolean') {
                                    formattedValue = value ? 'Ja' : 'Nein';
                                } else if (parameter.type === 'number' && parameter.unit) {
                                    formattedValue = `${value} ${parameter.unit}`;
                                } else if (parameter.type === 'select' && parameter.options) {
                                    const option = parameter.options.find(opt => opt.value === value);
                                    formattedValue = option ? option.text : value;
                                } else {
                                    formattedValue = value;
                                }

                                customParamValues.push(`${parameter.name}: ${formattedValue}`);
                            }
                        });

                        if (customParamValues.length > 0) {
                            customParamsText = customParamValues.join(', ');
                        }
                    }

                    row.innerHTML = `
                        <td>${formattedDate}</td>
                        <td>${flowText}</td>
                        <td>${tempText}</td>
                        <td>${symptoms}</td>
                        <td>${customParamsText}</td>
                    `;

                    // F√ºge Klick-Ereignis hinzu, um den Eintrag zu √∂ffnen
                    row.addEventListener('click', () => {
                        openEntryForm(entry.date);
                    });
                    row.style.cursor = 'pointer';

                    tableBody.appendChild(row);
                }

                // Aktualisiere die Paginierung
                updatePagination();
            }

            function updatePagination() {
                const paginationElement = document.getElementById('entriesPagination');
                paginationElement.innerHTML = '';

                if (totalPages <= 1) {
                    return;
                }

                // Zur√ºck-Button
                const prevButton = document.createElement('button');
                prevButton.textContent = '¬´';
                prevButton.disabled = currentPage === 1;
                prevButton.addEventListener('click', () => {
                    if (currentPage > 1) {
                        currentPage--;
                        displayPage(currentPage);
                    }
                });
                paginationElement.appendChild(prevButton);

                // Seitenzahlen
                for (let i = 1; i <= totalPages; i++) {
                    // Zeige nur 3 Seiten um die aktuelle Seite herum
                    if (
                        i === 1 ||
                        i === totalPages ||
                        (i >= currentPage - 1 && i <= currentPage + 1)
                    ) {
                        const pageButton = document.createElement('button');
                        pageButton.textContent = i;
                        pageButton.classList.toggle('active', i === currentPage);
                        pageButton.addEventListener('click', () => {
                            currentPage = i;
                            displayPage(currentPage);
                        });
                        paginationElement.appendChild(pageButton);
                    } else if (
                        (i === currentPage - 2 && currentPage > 3) ||
                        (i === currentPage + 2 && currentPage < totalPages - 2)
                    ) {
                        // F√ºge Auslassungspunkte hinzu
                        const ellipsis = document.createElement('span');
                        ellipsis.textContent = '...';
                        ellipsis.style.margin = '0 5px';
                        paginationElement.appendChild(ellipsis);
                    }
                }

                // Weiter-Button
                const nextButton = document.createElement('button');
                nextButton.textContent = '¬ª';
                nextButton.disabled = currentPage === totalPages;
                nextButton.addEventListener('click', () => {
                    if (currentPage < totalPages) {
                        currentPage++;
                        displayPage(currentPage);
                    }
                });
                paginationElement.appendChild(nextButton);
            }

            // Zeige die erste Seite
            displayPage(currentPage);
        }

        // Funktion zum Hinzuf√ºgen eines neuen Eintrags
        function addEntry(entry) {
            // F√ºge die Eintrag-ID hinzu
            entry.id = Date.now().toString();

            // Pr√ºfe, ob die Periode beginnt
            const isNewPeriod = entry.flow !== 'NONE' && !isInPeriod(entry.date);

            // Wenn eine neue Periode beginnt, erstelle einen neuen Zyklus
            if (isNewPeriod) {
                const lastCycle = appData.cycles.length > 0 ? appData.cycles[0] : null;

                // Neuer Zyklus
                const newCycle = {
                    id: Date.now().toString(),
                    startDate: entry.date,
                    endDate: null // Wird sp√§ter aktualisiert, wenn der n√§chste Zyklus beginnt
                };

                // Schlie√üe den letzten Zyklus ab, wenn vorhanden
                if (lastCycle) {
                    lastCycle.endDate = new Date(new Date(entry.date).getTime() - 86400000).toISOString().split('T')[0]; // Einen Tag vor dem neuen Zyklusstart
                }

                // F√ºge den neuen Zyklus hinzu
                appData.cycles.unshift(newCycle);
            }

            // Speichere den Eintrag
            appData.entries.unshift(entry);

            // Speichere die aktualisierten Daten
            saveData();

            // UI aktualisieren
            updateUI();
        }

        // Pr√ºfe, ob ein Datum in einer Periode liegt
        function isInPeriod(date) {
            const dateObj = new Date(date);

            // Pr√ºfe alle Eintr√§ge
            for (const entry of appData.entries) {
                if (entry.flow !== 'NONE') {
                    const entryDate = new Date(entry.date);

                    // Wenn das Datum innerhalb von 7 Tagen nach einem Periodeneintrag liegt,
                    // betrachten wir es als Teil der gleichen Periode
                    const diffTime = Math.abs(dateObj - entryDate);
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                    if (diffDays <= 7 && dateObj >= entryDate) {
                        return true;
                    }
                }
            }

            return false;
        }

        // Berechne den aktuellen Zyklustag und die Phase
        function calculateCycleStatus() {
            const today = new Date().toISOString().split('T')[0];
            let currentCycle = null;
            let cycleDay = 0;
            let phase = 'Unbekannt';
            let daysUntilNextPeriod = 0;

            // Finde den aktuellen Zyklus
            if (appData.cycles.length > 0) {
                currentCycle = appData.cycles[0];

                // Berechne Zyklustag
                const startDate = new Date(currentCycle.startDate);
                const currentDate = new Date();

                const diffTime = Math.abs(currentDate - startDate);
                cycleDay = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;

                // Bestimme die Phase
                if (isInPeriod(today)) {
                    phase = 'Periode';
                } else if (cycleDay <= 7) {
                    phase = 'Follikelphase (nach der Periode)';
                } else if (cycleDay <= 14) {
                    phase = 'Fruchtbare Phase';
                    if (cycleDay === 14) {
                        phase = 'Wahrscheinlicher Eisprung';
                    }
                } else {
                    phase = 'Lutealphase (nach dem Eisprung)';
                }

                // Berechne Tage bis zur n√§chsten Periode
                const avgCycleLength = calculateAvgCycleLength();
                daysUntilNextPeriod = avgCycleLength - cycleDay + 1;

                if (daysUntilNextPeriod < 0) {
                    daysUntilNextPeriod = 0;
                }
            }

            return {
                cycleDay,
                phase,
                daysUntilNextPeriod
            };
        }

        // Berechne durchschnittliche Zyklusl√§nge
        function calculateAvgCycleLength() {
            if (appData.cycles.length < 2) {
                return appData.settings.cycleLength;
            }

            let totalLength = 0;
            let completeCycles = 0;

            for (let i = 1; i < appData.cycles.length; i++) {
                const cycle = appData.cycles[i];

                if (cycle.endDate) {
                    const startDate = new Date(cycle.startDate);
                    const endDate = new Date(cycle.endDate);

                    const diffTime = Math.abs(endDate - startDate);
                    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;

                    totalLength += diffDays;
                    completeCycles++;
                }
            }

            return completeCycles > 0 ? Math.round(totalLength / completeCycles) : appData.settings.cycleLength;
        }

        // Berechne durchschnittliche Periodenl√§nge
        function calculateAvgPeriodLength() {
            const periodsByStartDate = {};

            // Gruppiere Periodeneintr√§ge nach Startdatum
            for (const entry of appData.entries) {
                if (entry.flow !== 'NONE') {
                    const date = entry.date;
                    let found = false;

                    // Pr√ºfe, ob dieser Eintrag zu einer bestehenden Periode geh√∂rt
                    for (const startDate in periodsByStartDate) {
                        const period = periodsByStartDate[startDate];
                        const lastDate = period[period.length - 1];

                        const lastDateTime = new Date(lastDate).getTime();
                        const entryDateTime = new Date(date).getTime();

                        // Wenn der Eintrag innerhalb eines Tages nach dem letzten Periodeneintrag liegt,
                        // geh√∂rt er zur gleichen Periode
                        if (entryDateTime - lastDateTime <= 86400000) {
                            period.push(date);
                            found = true;
                            break;
                        }
                    }

                    // Wenn der Eintrag zu keiner bestehenden Periode geh√∂rt, starte eine neue
                    if (!found) {
                        periodsByStartDate[date] = [date];
                    }
                }
            }

            // Berechne die durchschnittliche Periodenl√§nge
            let totalLength = 0;
            let periodCount = 0;

            for (const startDate in periodsByStartDate) {
                const period = periodsByStartDate[startDate];
                totalLength += period.length;
                periodCount++;
            }

            return periodCount > 0 ? Math.round(totalLength / periodCount) : appData.settings.periodLength;
        }

        // H√§ufigste Symptome ermitteln
        function getTopSymptoms() {
            const symptomCount = {};
            let totalEntries = 0;

            for (const entry of appData.entries) {
                if (entry.symptoms && entry.symptoms.length > 0) {
                    totalEntries++;

                    for (const symptom of entry.symptoms) {
                        if (!symptomCount[symptom]) {
                            symptomCount[symptom] = 0;
                        }
                        symptomCount[symptom]++;
                    }
                }
            }

            // Sortiere Symptome nach H√§ufigkeit
            const sortedSymptoms = Object.keys(symptomCount).sort((a, b) => {
                return symptomCount[b] - symptomCount[a];
            });

            // Erstelle Ergebnisarray mit Prozentangaben
            const result = sortedSymptoms.map(symptom => {
                const percentage = totalEntries > 0 ? Math.round((symptomCount[symptom] / totalEntries) * 100) : 0;
                return {
                    name: getSymptomName(symptom),
                    percentage
                };
            });

            return result.slice(0, 3); // Gibt die 3 h√§ufigsten Symptome zur√ºck
        }

        // Symptom-IDs in lesbare Namen umwandeln
        function getSymptomName(symptomId) {
            const symptomNames = {
                'HEADACHE': 'Kopfschmerzen',
                'CRAMPS': 'Kr√§mpfe',
                'BACKACHE': 'R√ºckenschmerzen',
                'FATIGUE': 'M√ºdigkeit',
                'BLOATING': 'Bl√§hungen',
                'MOOD': 'Stimmungsschwankungen'
            };

            return symptomNames[symptomId] || symptomId;
        }

        // Statistiken f√ºr benutzerdefinierte Parameter
        function updateCustomParameterStats() {
            const statsContainer = document.getElementById('customParametersStats');
            statsContainer.innerHTML = '';

            // Pr√ºfe, ob benutzerdefinierte Parameter existieren
            if (!appData.customParameters || appData.customParameters.length === 0) {
                return;
            }

            // Erstelle eine √úberschrift
            const header = document.createElement('h3');
            header.className = 'section-title';
            header.textContent = 'Benutzerdefinierte Parameter Statistik';
            statsContainer.appendChild(header);

            // Erstelle einen Container f√ºr die Statistik-Karten
            const cardsContainer = document.createElement('div');
            cardsContainer.className = 'stats-container';
            statsContainer.appendChild(cardsContainer);

            // Verarbeite jeden benutzerdefinierten Parameter
            appData.customParameters.forEach(param => {
                // Sammle Daten f√ºr diesen Parameter
                const paramData = collectParameterData(param);

                // Erstelle eine Statistik-Karte
                const card = document.createElement('div');
                card.className = 'stat-card';

                // Titel mit Symbol
                const title = document.createElement('div');
                title.className = 'stat-title';
                title.innerHTML = `${param.icon} ${param.name}`;
                card.appendChild(title);

                // Inhalt je nach Parametertyp
                const content = document.createElement('div');

                if (param.type === 'boolean') {
                    const yesCount = paramData.trueCount;
                    const totalCount = paramData.totalCount;
                    const percentage = totalCount > 0 ? Math.round((yesCount / totalCount) * 100) : 0;

                    content.innerHTML = `
                        <p>In ${percentage}% der Eintr√§ge als "Ja" markiert</p>
                        <p>${yesCount} von ${totalCount} Tagen</p>
                    `;
                } else if (param.type === 'number') {
                    content.innerHTML = `
                        <p>Durchschnitt: ${paramData.average !== null ? paramData.average.toFixed(1) : '--'} ${param.unit || ''}</p>
                        <p>Min: ${paramData.min !== null ? paramData.min : '--'} ${param.unit || ''}</p>
                        <p>Max: ${paramData.max !== null ? paramData.max : '--'} ${param.unit || ''}</p>
                        <p>Eingetragen an ${paramData.totalCount} Tagen</p>
                    `;
                } else if (param.type === 'select') {
                    // Zeige die 3 h√§ufigsten Optionen an
                    if (paramData.optionCounts && Object.keys(paramData.optionCounts).length > 0) {
                        const sortedOptions = Object.entries(paramData.optionCounts)
                            .sort((a, b) => b[1] - a[1])
                            .slice(0, 3);

                        let optionsHtml = '<p>H√§ufigste Auswahlen:</p><ul>';

                        sortedOptions.forEach(([optionValue, count]) => {
                            const option = param.options.find(opt => opt.value === optionValue);
                            const optionText = option ? option.text : optionValue;
                            const percentage = Math.round((count / paramData.totalCount) * 100);

                            optionsHtml += `<li>${optionText}: ${percentage}%</li>`;
                        });

                        optionsHtml += '</ul>';
                        content.innerHTML = optionsHtml;
                    } else {
                        content.textContent = 'Keine Daten vorhanden';
                    }
                } else if (param.type === 'text') {
                    content.innerHTML = `<p>Eingetragen an ${paramData.totalCount} Tagen</p>`;
                }

                card.appendChild(content);
                cardsContainer.appendChild(card);
            });
        }

        // Sammle Daten f√ºr einen bestimmten Parameter
        function collectParameterData(parameter) {
            const data = {
                totalCount: 0,
                trueCount: 0,
                values: [],
                min: null,
                max: null,
                average: null,
                optionCounts: {}
            };

            // Durchlaufe alle Eintr√§ge
            appData.entries.forEach(entry => {
                if (entry.customParameters && entry.customParameters[parameter.id] !== undefined) {
                    const value = entry.customParameters[parameter.id];

                    data.totalCount++;

                    if (parameter.type === 'boolean') {
                        if (value === true) {
                            data.trueCount++;
                        }
                    } else if (parameter.type === 'number') {
                        data.values.push(value);

                        // Aktualisiere Min/Max
                        if (data.min === null || value < data.min) {
                            data.min = value;
                        }

                        if (data.max === null || value > data.max) {
                            data.max = value;
                        }
                    } else if (parameter.type === 'select') {
                        // Z√§hle die H√§ufigkeit jeder Option
                        if (!data.optionCounts[value]) {
                            data.optionCounts[value] = 0;
                        }

                        data.optionCounts[value]++;
                    }
                }
            });

            // Berechne Durchschnitt f√ºr numerische Parameter
            if (parameter.type === 'number' && data.values.length > 0) {
                const sum = data.values.reduce((acc, val) => acc + val, 0);
                data.average = sum / data.values.length;
            }

            return data;
        }

        // Aktualisiere die UI
        function updateUI() {
            updateCycleStatus();
            updateCalendar();
            updateStatistics();
            updateCustomParameterStats();
            updateBackupSettings();
            updateBackupHistory();
            updateQuestDate();
            updateCustomParameterItems();
        }

        // Aktualisiere den Zyklusstatus
        function updateCycleStatus() {
            const status = calculateCycleStatus();

            document.getElementById('cycleDay').textContent = `Tag ${status.cycleDay}`;
            document.getElementById('cyclePhase').textContent = status.phase;
            document.getElementById('nextPeriod').textContent = status.daysUntilNextPeriod;

            // Aktualisiere das Zyklusrad mit farbcodierten Segmenten
            updateCycleWheel(status);
        }

        // Aktualisiere das Zyklusrad
        function updateCycleWheel(status) {
            const cycleRing = document.getElementById('cycleRing');
            cycleRing.innerHTML = '';

            const avgCycleLength = calculateAvgCycleLength();

            // Bestimme Phasen basierend auf dem Zyklustag
            let periodEnd = Math.min(appData.settings.periodLength, 7);
            let fertileStart = 9;
            let fertileEnd = 16;

            // Setze Hintergrundfarbe entsprechend der Phase
            let backgroundColor;
            if (status.phase.includes('Periode')) {
                backgroundColor = 'var(--primary-color)';
            } else if (status.phase.includes('Fruchtbare Phase') || status.phase.includes('Eisprung')) {
                backgroundColor = 'var(--tertiary-color)';
            } else {
                backgroundColor = '#e0e0e0';
            }

            // Vollst√§ndiger Kreis in der Hintergrundfarbe
            cycleRing.style.borderColor = backgroundColor;

            // Erstelle Kreissegmente f√ºr die verschiedenen Zyklusphasen
            // Periodenphase (rot)
            if (periodEnd > 0) {
                createCycleSegment(0, (periodEnd / avgCycleLength) * 360, 'var(--primary-color)');
            }

            // Fruchtbare Phase (orange)
            createCycleSegment((fertileStart / avgCycleLength) * 360, ((fertileEnd - fertileStart) / avgCycleLength) * 360, 'var(--tertiary-color)');

            // Eisprung-Markierung, falls aktuell
            if (status.phase.includes('Eisprung')) {
                const ovulationIndicator = document.createElement('div');
                ovulationIndicator.textContent = 'üåº';
                ovulationIndicator.style.position = 'absolute';
                ovulationIndicator.style.top = '50%';
                ovulationIndicator.style.right = '30px';
                ovulationIndicator.style.transform = 'translateY(-50%)';
                ovulationIndicator.style.fontSize = '1.5rem';
                cycleRing.appendChild(ovulationIndicator);
            }

            // Aktueller Tag-Marker
            const dayMarker = document.createElement('div');
            dayMarker.style.position = 'absolute';
            dayMarker.style.width = '15px';
            dayMarker.style.height = '15px';
            dayMarker.style.borderRadius = '50%';
            dayMarker.style.backgroundColor = 'white';
            dayMarker.style.border = '2px solid #4361ee';

            // Berechne Position auf dem Kreis
            const angle = ((status.cycleDay - 1) / avgCycleLength) * 2 * Math.PI;
            const radius = 110; // Radius des Kreises (220px / 2)
            const x = radius * Math.sin(angle);
            const y = -radius * Math.cos(angle);

            dayMarker.style.top = `${110 + y}px`;
            dayMarker.style.left = `${110 + x}px`;
            dayMarker.style.transform = 'translate(-50%, -50%)';
            dayMarker.style.zIndex = '5';

            cycleRing.appendChild(dayMarker);
        }

        // Funktion zum Erstellen eines Kreissegments
        function createCycleSegment(startAngle, sweepAngle, color) {
            const cycleRing = document.getElementById('cycleRing');

            // Erstelle ein Segment f√ºr die angegebene Phase
            const segment = document.createElement('div');
            segment.classList.add('cycle-segment');

            // F√ºr den Start-Winkel
            const segmentInner = document.createElement('div');
            segmentInner.classList.add('cycle-segment-inner');
            segmentInner.style.setProperty('--rotation', `${startAngle}deg`);
            segmentInner.style.setProperty('--segment-color', color);

            segment.appendChild(segmentInner);
            cycleRing.appendChild(segment);

            // F√ºr den End-Winkel, falls der Sweep-Winkel > 180 Grad ist
            if (sweepAngle > 180) {
                const segment2 = document.createElement('div');
                segment2.classList.add('cycle-segment');
                segment2.style.transform = 'rotate(180deg)';

                const segmentInner2 = document.createElement('div');
                segmentInner2.classList.add('cycle-segment-inner');
                segmentInner2.style.setProperty('--rotation', `${startAngle + 180}deg`);
                segmentInner2.style.setProperty('--segment-color', color);

                segment2.appendChild(segmentInner2);
                cycleRing.appendChild(segment2);
            }
        }

        // Aktualisiere das Datum f√ºr die t√§gliche Quest
        function updateQuestDate() {
            const dateElement = document.getElementById('questDate');
            const dayElement = document.getElementById('questDay');

            const options = { day: '2-digit', month: 'long', year: 'numeric' };
            dateElement.textContent = currentQuestDate.toLocaleDateString('de-DE', options);
            dayElement.textContent = currentQuestDate.toLocaleDateString('de-DE', { weekday: 'long' });

            // Pr√ºfe, ob es f√ºr dieses Datum Eintr√§ge gibt
            const dateString = currentQuestDate.toISOString().split('T')[0];
            const existingEntry = appData.entries.find(entry => entry.date === dateString);

            // Aktualisiere die visuellen Indikatoren in den Quest-Items
            updateQuestItemIndicators(existingEntry);
        }

        // Aktualisiere die Indikatoren in den Quest-Items basierend auf den vorhandenen Daten
        function updateQuestItemIndicators(entry) {
            // Zur√ºcksetzen aller Indikatoren
            document.querySelectorAll('.quest-item').forEach(item => {
                item.style.backgroundColor = '#f8f8f8';
            });

            if (!entry) return;

            // Periode
            if (entry.flow !== 'NONE') {
                document.querySelector('[data-type="period"]').style.backgroundColor = '#ffe6e6';
            }

            // Temperatur
            if (entry.temperature) {
                document.querySelector('[data-type="temperature"]').style.backgroundColor = '#fff2e6';
            }

            // Schleim
            if (entry.cervicalMucus) {
                document.querySelector('[data-type="mucus"]').style.backgroundColor = '#e6f7ff';
            }

            // Brustgef√ºhl
            if (entry.breastFeeling) {
                document.querySelector('[data-type="breast"]').style.backgroundColor = '#ffe6f2';
            }

            // Symptome
            if (entry.symptoms && entry.symptoms.length > 0) {
                if (entry.symptoms.includes('HEADACHE')) {
                    document.querySelector('[data-type="pain"]').style.backgroundColor = '#ffe6eb';
                }
                if (entry.symptoms.includes('MOOD')) {
                    document.querySelector('[data-type="mood"]').style.backgroundColor = '#e6ecff';
                }
            }

            // Notizen
            if (entry.notes && entry.notes.trim() !== '') {
                document.querySelector('[data-type="notes"]').style.backgroundColor = '#f2f2f2';
            }

            // Benutzerdefinierte Parameter
            if (entry.customParameters) {
                appData.customParameters.forEach(param => {
                    const value = entry.customParameters[param.id];

                    if (value !== undefined && value !== null && value !== '') {
                        const questItem = document.querySelector(`[data-type="custom-${param.id}"]`);
                        if (questItem) {
                            questItem.style.backgroundColor = '#f0e6ff';
                        }
                    }
                });
            }
        }

        // Kalenderfunktionen
        function setupCalendar() {
            const calendarGrid = document.getElementById('calendarGrid');
            const currentMonthElement = document.getElementById('currentMonth');
            const prevMonthButton = document.getElementById('prevMonth');
            const nextMonthButton = document.getElementById('nextMonth');

            let currentDate = new Date();

            // Funktion zum Rendern des Kalenders
            function renderCalendar() {
                calendarGrid.innerHTML = '';

                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();

                currentMonthElement.textContent = `${currentDate.toLocaleString('de-DE', { month: 'long' })} ${year}`;

                const firstDay = new Date(year, month, 1);
                const lastDay = new Date(year, month + 1, 0);

                // Berechne, mit welchem Wochentag der Monat beginnt (0 = Sonntag, 1 = Montag, ...)
                let firstDayOfGrid = new Date(firstDay);
                const firstDayWeekday = firstDay.getDay() || 7; // Wenn 0 (Sonntag), dann 7
                firstDayOfGrid.setDate(firstDayOfGrid.getDate() - (firstDayWeekday - 1));

                // Berechne, an welchem Wochentag der Monat endet
                const lastDayWeekday = lastDay.getDay() || 7;
                let lastDayOfGrid = new Date(lastDay);
                lastDayOfGrid.setDate(lastDayOfGrid.getDate() + (7 - lastDayWeekday));

                // Erstelle Kalendertage
                let currentGridDay = new Date(firstDayOfGrid);

                while (currentGridDay <= lastDayOfGrid) {
                    const dayElement = document.createElement('div');
                    dayElement.classList.add('calendar-day');

                    const dayNumber = currentGridDay.getDate();
                    dayElement.textContent = dayNumber;

                    // Markiere Tage au√üerhalb des aktuellen Monats
                    if (currentGridDay.getMonth() !== month) {
                        dayElement.style.opacity = '0.5';
                    }

                    // Markiere Tage mit Eintr√§gen
                    const dateString = currentGridDay.toISOString().split('T')[0];
                    const dayEntry = appData.entries.find(entry => entry.date === dateString);

                    if (dayEntry) {
                        // Markiere Periode
                        if (dayEntry.flow !== 'NONE') {
                            dayElement.classList.add('period');

                            // F√ºge Intensit√§tsmarkierung hinzu
                            const intensityMap = {
                                'SPOTTING': 'ü©∏‚ÇÅ',
                                'LIGHT': 'ü©∏‚ÇÇ',
                                'MEDIUM': 'ü©∏‚ÇÉ',
                                'HEAVY': 'ü©∏‚ÇÑ'
                            };

                            if (intensityMap[dayEntry.flow]) {
                                const symbol = document.createElement('div');
                                symbol.className = 'day-symbol';
                                symbol.textContent = intensityMap[dayEntry.flow];
                                dayElement.appendChild(symbol);
                            }
                        }

                        // Markiere Geschlechtsverkehr
                        if (dayEntry.intercourse) {
                            const symbol = document.createElement('div');
                            symbol.className = 'day-symbol';
                            symbol.textContent = 'üíú';
                            dayElement.appendChild(symbol);
                        }

                        // Markiere Symptome oder benutzerdefinierte Parameter
                        if ((dayEntry.symptoms && dayEntry.symptoms.length > 0) ||
                            (dayEntry.customParameters && Object.keys(dayEntry.customParameters).length > 0)) {
                            const indicator = document.createElement('div');
                            indicator.classList.add('day-indicator', 'symptom-indicator');
                            dayElement.appendChild(indicator);
                        }
                    }

                    // Markiere fruchtbare Tage und Eisprung
                    const cycles = appData.cycles;
                    if (cycles.length > 0) {
                        const currentCycle = cycles[0];
                        const cycleStart = new Date(currentCycle.startDate);

                        // Berechne Zyklusl√§nge
                        const avgCycleLength = calculateAvgCycleLength();

                        // Berechne Eisprung (ca. 14 Tage vor der n√§chsten Periode)
                        const ovulationDate = new Date(cycleStart);
                        ovulationDate.setDate(ovulationDate.getDate() + avgCycleLength - 14);

                        // Berechne fruchtbares Fenster (5 Tage vor bis 1 Tag nach Eisprung)
                        const fertileStart = new Date(ovulationDate);
                        fertileStart.setDate(fertileStart.getDate() - 5);

                        const fertileEnd = new Date(ovulationDate);
                        fertileEnd.setDate(fertileEnd.getDate() + 1);

                        // Markiere Eisprung
                        if (currentGridDay.toDateString() === ovulationDate.toDateString()) {
                            dayElement.classList.add('ovulation');

                            // F√ºge Eisprung-Symbol hinzu
                            const symbol = document.createElement('div');
                            symbol.className = 'day-symbol';
                            symbol.textContent = 'üåº';
                            dayElement.appendChild(symbol);
                        }

                         // Markiere fruchtbare Tage
                        if (currentGridDay >= fertileStart && currentGridDay <= fertileEnd &&
                            !dayElement.classList.contains('period') && !dayElement.classList.contains('ovulation')) {
                            dayElement.classList.add('fertile');

                            // F√ºge Fruchtbar-Symbol hinzu
                            const symbol = document.createElement('div');
                            symbol.className = 'day-symbol';
                            symbol.textContent = 'üü†';
                            dayElement.appendChild(symbol);
                        }
                    }

                    // F√ºge Mondphase hinzu (vereinfacht dargestellt, alle 7 Tage)
                    if (dayNumber % 7 === 0) {
                        const symbol = document.createElement('div');
                        symbol.className = 'day-symbol';
                        symbol.textContent = 'üåô';
                        symbol.style.fontSize = '0.6rem';
                        dayElement.appendChild(symbol);
                    }

                    // Klick-Ereignis hinzuf√ºgen, um das Formular f√ºr diesen Tag zu √∂ffnen
                    dayElement.addEventListener('click', () => {
                        openEntryForm(dateString);
                    });

                    calendarGrid.appendChild(dayElement);

                    // Gehe zum n√§chsten Tag
                    currentGridDay.setDate(currentGridDay.getDate() + 1);
                }
            }

            // Event-Listener f√ºr Monatsnavigation
            prevMonthButton.addEventListener('click', () => {
                currentDate.setMonth(currentDate.getMonth() - 1);
                renderCalendar();
            });

            nextMonthButton.addEventListener('click', () => {
                currentDate.setMonth(currentDate.getMonth() + 1);
                renderCalendar();
            });

            // Initialer Kalender
            renderCalendar();
        }

        // Aktualisiere den Kalender
        function updateCalendar() {
            setupCalendar();
        }

        // √ñffne das Eingabeformular f√ºr ein bestimmtes Datum
        function openEntryForm(dateString) {
            // Setze das Datum im Formular
            document.getElementById('entryDate').value = dateString;

            // Setze den Dialog-Titel
            document.getElementById('dialogTitle').textContent = `Eintrag f√ºr ${new Date(dateString).toLocaleDateString('de-DE')}`;

            // Bereite die benutzerdefinierten Parameter-Felder vor
            prepareCustomParameterFields();

            // Zeige den Dialog
            document.getElementById('entryDialog').style.display = 'flex';

            // F√ºlle das Formular, falls bereits ein Eintrag existiert
            const existingEntry = appData.entries.find(entry => entry.date === dateString);

            if (existingEntry) {
                // Setze Periodenfluss
                const flowRadio = document.getElementById(`flow-${existingEntry.flow.toLowerCase()}`);
                if (flowRadio) {
                    flowRadio.checked = true;
                }

                // Setze Temperatur
                if (existingEntry.temperature) {
                    document.getElementById('temperature').value = existingEntry.temperature;
                } else {
                    document.getElementById('temperature').value = '';
                }

                // Setze Zervixschleim
                document.getElementById('cervicalMucus').value = existingEntry.cervicalMucus || '';

                // Setze Brustgef√ºhl
                document.getElementById('breastFeeling').value = existingEntry.breastFeeling || '';

                // Setze Symptome
                document.querySelectorAll('input[name="symptoms"]').forEach(checkbox => {
                    checkbox.checked = existingEntry.symptoms && existingEntry.symptoms.includes(checkbox.value);
                });

                // Setze Notizen
                document.getElementById('notes').value = existingEntry.notes || '';

                // Setze benutzerdefinierte Parameter-Werte
                if (existingEntry.customParameters) {
                    appData.customParameters.forEach(param => {
                        const paramId = param.id;
                        const value = existingEntry.customParameters[paramId];

                        if (value !== undefined) {
                            if (param.type === 'boolean') {
                                const checkbox = document.getElementById(`param-${paramId}`);
                                if (checkbox) {
                                    checkbox.checked = value;
                                }
                            } else if (param.type === 'number' || param.type === 'text') {
                                const input = document.getElementById(`param-${paramId}`);
                                if (input) {
                                    input.value = value;
                                }
                            } else if (param.type === 'select') {
                                const select = document.getElementById(`param-${paramId}`);
                                if (select) {
                                    select.value = value;
                                }
                            }
                        }
                    });
                }
            } else {
                // Setze Standardwerte, wenn kein Eintrag existiert
                document.getElementById('flow-none').checked = true;
                document.getElementById('temperature').value = '';
                document.getElementById('cervicalMucus').value = '';
                document.getElementById('breastFeeling').value = '';
                document.querySelectorAll('input[name="symptoms"]').forEach(checkbox => {
                    checkbox.checked = false;
                });
                document.getElementById('notes').value = '';

                // Setze benutzerdefinierte Parameter auf Standardwerte
                resetCustomParameterFields();
            }
        }

        // Bereite die benutzerdefinierten Parameter-Felder vor
        function prepareCustomParameterFields() {
            const customFieldsContainer = document.getElementById('customParameterFields');
            customFieldsContainer.innerHTML = '';

            if (!appData.customParameters || appData.customParameters.length === 0) {
                return;
            }

            // F√ºge einen Abschnitt-Titel hinzu
            const sectionTitle = document.createElement('h4');
            sectionTitle.textContent = 'Benutzerdefinierte Parameter';
            sectionTitle.style.marginTop = '20px';
            sectionTitle.style.borderBottom = '1px solid #eee';
            sectionTitle.style.paddingBottom = '10px';
            customFieldsContainer.appendChild(sectionTitle);

            // Erstelle Felder f√ºr jeden Parameter
            appData.customParameters.forEach(param => {
                const formGroup = document.createElement('div');
                formGroup.className = 'form-group';

                // Label mit Icon
                const label = document.createElement('label');
                label.innerHTML = `${param.icon} ${param.name}`;
                formGroup.appendChild(label);

                // Erstelle das entsprechende Eingabefeld basierend auf dem Parametertyp
                if (param.type === 'boolean') {
                    // Checkbox f√ºr Ja/Nein-Parameter
                    const checkbox = document.createElement('div');
                    checkbox.className = 'switch-container';
                    checkbox.innerHTML = `
                        <label class="switch">
                            <input type="checkbox" id="param-${param.id}">
                            <span class="slider"></span>
                        </label>
                        <span>Ja/Nein</span>
                    `;
                    formGroup.appendChild(checkbox);
                } else if (param.type === 'number') {
                    // Numerisches Eingabefeld
                    const inputGroup = document.createElement('div');
                    inputGroup.style.display = 'flex';
                    inputGroup.style.alignItems = 'center';

                    const input = document.createElement('input');
                    input.type = 'number';
                    input.id = `param-${param.id}`;
                    input.step = 'any';
                    input.min = param.minValue || 0;
                    input.max = param.maxValue || 100;
                    input.placeholder = `z.B. ${param.minValue || 0}-${param.maxValue || 100}`;
                    input.style.flex = '1';

                    inputGroup.appendChild(input);

                    // Einheit hinzuf√ºgen, falls vorhanden
                    if (param.unit) {
                        const unitLabel = document.createElement('span');
                        unitLabel.textContent = param.unit;
                        unitLabel.style.marginLeft = '10px';
                        unitLabel.style.color = '#666';
                        inputGroup.appendChild(unitLabel);
                    }

                    formGroup.appendChild(inputGroup);
                } else if (param.type === 'text') {
                    // Textfeld
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.id = `param-${param.id}`;
                    input.placeholder = 'Text eingeben...';
                    formGroup.appendChild(input);
                } else if (param.type === 'select') {
                    // Auswahlfeld
                    const select = document.createElement('select');
                    select.id = `param-${param.id}`;

                    // Leere Option
                    const emptyOption = document.createElement('option');
                    emptyOption.value = '';
                    emptyOption.textContent = 'Nicht eingetragen';
                    select.appendChild(emptyOption);

                    // Optionen aus dem Parameter
                    if (param.options && param.options.length > 0) {
                        param.options.forEach(option => {
                            const optionElement = document.createElement('option');
                            optionElement.value = option.value;
                            optionElement.textContent = option.text;
                            select.appendChild(optionElement);
                        });
                    }

                    formGroup.appendChild(select);
                }

                customFieldsContainer.appendChild(formGroup);
            });
        }

        // Setze benutzerdefinierte Parameter-Felder zur√ºck
        function resetCustomParameterFields() {
            appData.customParameters.forEach(param => {
                const paramId = param.id;

                if (param.type === 'boolean') {
                    const checkbox = document.getElementById(`param-${paramId}`);
                    if (checkbox) {
                        checkbox.checked = false;
                    }
                } else if (param.type === 'number' || param.type === 'text') {
                    const input = document.getElementById(`param-${paramId}`);
                    if (input) {
                        input.value = '';
                    }
                } else if (param.type === 'select') {
                    const select = document.getElementById(`param-${paramId}`);
                    if (select) {
                        select.value = '';
                    }
                }
            });
        }

        // Aktualisiere die Liste der benutzerdefinierten Parameter im Einstellungen-Tab
        function updateCustomParametersList() {
            const container = document.getElementById('customParametersContainer');
            const infoText = document.getElementById('noCustomParametersInfo');

            // Leere den Container
            container.innerHTML = '';

            // Zeige Info-Text, wenn keine Parameter vorhanden sind
            if (!appData.customParameters || appData.customParameters.length === 0) {
                infoText.style.display = 'block';
                return;
            }

            infoText.style.display = 'none';

            // Erstelle ein Element f√ºr jeden Parameter
            appData.customParameters.forEach(param => {
                const paramItem = document.createElement('div');
                paramItem.className = 'custom-parameter-item';

                // Parameter-Icon und Name
                const paramInfo = document.createElement('div');
                paramInfo.innerHTML = `
                    <div class="custom-parameter-name">${param.icon} ${param.name}</div>
                    <div class="custom-parameter-type">${getParameterTypeText(param.type)}</div>
                `;

                // Aktions-Buttons
                const paramActions = document.createElement('div');
                paramActions.className = 'custom-parameter-actions';

                const editButton = document.createElement('button');
                editButton.textContent = 'Bearbeiten';
                editButton.className = 'secondary';
                editButton.addEventListener('click', () => {
                    editCustomParameter(param);
                });

                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'L√∂schen';
                deleteButton.className = 'secondary';
                deleteButton.addEventListener('click', () => {
                    if (confirm(`M√∂chtest du den Parameter "${param.name}" wirklich l√∂schen? Alle zugeh√∂rigen Daten gehen verloren.`)) {
                        deleteCustomParameter(param.id);
                    }
                });

                paramActions.appendChild(editButton);
                paramActions.appendChild(deleteButton);

                paramItem.appendChild(paramInfo);
                paramItem.appendChild(paramActions);

                container.appendChild(paramItem);
            });
        }

        // Typ-Text f√ºr einen Parametertyp abrufen
        function getParameterTypeText(type) {
            switch (type) {
                case 'boolean': return 'Ja/Nein';
                case 'number': return 'Zahlenwert';
                case 'text': return 'Textfeld';
                case 'select': return 'Auswahlfeld';
                default: return type;
            }
        }

        // Benutzerdefinierte Parameter-Items f√ºr die t√§gliche Quest aktualisieren
        function updateCustomParameterItems() {
            const container = document.getElementById('dailyQuestContainer');

            // Entferne alle benutzerdefinierten Parameter-Items
            document.querySelectorAll('.quest-item[data-type^="custom-"]').forEach(item => {
                item.remove();
            });

            // F√ºge neue Items f√ºr benutzerdefinierte Parameter hinzu
            if (appData.customParameters && appData.customParameters.length > 0) {
                appData.customParameters.forEach(param => {
                    const questItem = document.createElement('div');
                    questItem.className = 'quest-item';
                    questItem.setAttribute('data-type', `custom-${param.id}`);

                    const iconElement = document.createElement('div');
                    iconElement.className = 'quest-icon icon-custom';
                    iconElement.style.color = param.color;
                    iconElement.style.borderColor = param.color;
                    iconElement.textContent = param.icon;

                    const labelElement = document.createElement('div');
                    labelElement.className = 'quest-label';
                    labelElement.textContent = param.name;

                    questItem.appendChild(iconElement);
                    questItem.appendChild(labelElement);

                    // Event-Listener zum √ñffnen des Formulars
                    questItem.addEventListener('click', () => {
                        const dateString = currentQuestDate.toISOString().split('T')[0];
                        openEntryForm(dateString);

                        // Fokussiere auf das entsprechende Feld
                        setTimeout(() => {
                            const field = document.getElementById(`param-${param.id}`);
                            if (field) {
                                field.focus();
                            }
                        }, 300);
                    });

                    container.appendChild(questItem);
                });
            }
        }

        // F√ºge einen neuen benutzerdefinierten Parameter hinzu
        function addCustomParameter(paramData) {
            if (!appData.customParameters) {
                appData.customParameters = [];
            }

            // Generiere eine eindeutige ID
            const newId = `custom_${Date.now()}`;

            // Erstelle den neuen Parameter
            const newParameter = {
                id: newId,
                name: paramData.name,
                icon: paramData.icon,
                color: paramData.color,
                type: paramData.type
            };

            // F√ºge zus√§tzliche Eigenschaften je nach Typ hinzu
            if (paramData.type === 'number') {
                newParameter.unit = paramData.unit || '';
                newParameter.minValue = paramData.minValue !== undefined ? paramData.minValue : 0;
                newParameter.maxValue = paramData.maxValue !== undefined ? paramData.maxValue : 100;
            } else if (paramData.type === 'select') {
                newParameter.options = paramData.options || [];
            }

            // F√ºge den Parameter hinzu
            appData.customParameters.push(newParameter);

            // Speichere die Daten
            saveData();

            // Aktualisiere die UI
            updateCustomParametersList();
            updateCustomParameterItems();

            return newParameter;
        }

        // Aktualisiere einen bestehenden benutzerdefinierten Parameter
        function updateCustomParameter(paramId, paramData) {
            const paramIndex = appData.customParameters.findIndex(p => p.id === paramId);

            if (paramIndex === -1) {
                console.error('Parameter nicht gefunden:', paramId);
                return null;
            }

            // Aktualisiere die Eigenschaften
            appData.customParameters[paramIndex] = {
                ...appData.customParameters[paramIndex],
                name: paramData.name,
                icon: paramData.icon,
                color: paramData.color
            };

            // Aktualisiere typspezifische Eigenschaften
            if (paramData.type === 'number') {
                appData.customParameters[paramIndex].unit = paramData.unit || '';
                appData.customParameters[paramIndex].minValue = paramData.minValue !== undefined ? paramData.minValue : 0;
                appData.customParameters[paramIndex].maxValue = paramData.maxValue !== undefined ? paramData.maxValue : 100;
            } else if (paramData.type === 'select' && paramData.options) {
                appData.customParameters[paramIndex].options = paramData.options;
            }

            // Speichere die Daten
            saveData();

            // Aktualisiere die UI
            updateCustomParametersList();
            updateCustomParameterItems();

            return appData.customParameters[paramIndex];
        }

        // L√∂sche einen benutzerdefinierten Parameter
        function deleteCustomParameter(paramId) {
            // Entferne den Parameter aus dem Array
            appData.customParameters = appData.customParameters.filter(p => p.id !== paramId);

            // Entferne die Daten dieses Parameters aus allen Eintr√§gen
            appData.entries.forEach(entry => {
                if (entry.customParameters && entry.customParameters[paramId] !== undefined) {
                    delete entry.customParameters[paramId];
                }
            });

            // Speichere die Daten
            saveData();

            // Aktualisiere die UI
            updateCustomParametersList();
            updateCustomParameterItems();
            updateCustomParameterStats();

            showNotification('Parameter erfolgreich gel√∂scht.', 'success');
        }

        // Parameter-Dialog-Funktionalit√§t
        function setupParameterDialog() {
            const dialog = document.getElementById('customParameterDialog');
            const closeBtn = document.getElementById('parameterDialogClose');

            // Schlie√üen durch Klick auf X
            closeBtn.addEventListener('click', () => {
                dialog.style.display = 'none';
            });

            // Schlie√üen durch Klick au√üerhalb des Dialogs
            dialog.addEventListener('click', (event) => {
                if (event.target === dialog) {
                    dialog.style.display = 'none';
                }
            });

            // Event-Listener f√ºr Parametertyp-√Ñnderung
            document.getElementById('parameterType').addEventListener('change', function() {
                const type = this.value;

                // Blende alle typspezifischen Container aus
                document.getElementById('numberOptionsContainer').style.display = 'none';
                document.getElementById('selectOptionsContainer').style.display = 'none';

                // Blende den entsprechenden Container ein
                if (type === 'number') {
                    document.getElementById('numberOptionsContainer').style.display = 'block';
                } else if (type === 'select') {
                    document.getElementById('selectOptionsContainer').style.display = 'block';
                }
            });

            // Event-Listener f√ºr Icon-Auswahl
            document.querySelectorAll('#iconSelector .icon-option').forEach(option => {
                option.addEventListener('click', function() {
                    // Entferne 'selected' von allen Icons
                    document.querySelectorAll('#iconSelector .icon-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });

                    // F√ºge 'selected' zum ausgew√§hlten Icon hinzu
                    this.classList.add('selected');

                    // Setze den Wert im versteckten Feld
                    document.getElementById('selectedIcon').value = this.getAttribute('data-icon');
                });
            });

            // Event-Listener f√ºr Farb-Auswahl
            document.querySelectorAll('#colorSelector .color-option').forEach(option => {
                option.addEventListener('click', function() {
                    // Entferne 'selected' von allen Farben
                    document.querySelectorAll('#colorSelector .color-option').forEach(opt => {
                        opt.classList.remove('selected');
                    });

                    // F√ºge 'selected' zur ausgew√§hlten Farbe hinzu
                    this.classList.add('selected');

                    // Setze den Wert im versteckten Feld
                    document.getElementById('selectedColor').value = this.getAttribute('data-color');
                });
            });

            // Event-Listener f√ºr "Option hinzuf√ºgen"-Button
            document.getElementById('addOption').addEventListener('click', function() {
                addSelectOption();
            });

            // Event-Listener f√ºr Formularabgabe
            document.getElementById('customParameterForm').addEventListener('submit', function(event) {
                event.preventDefault();

                // Sammle Formulardaten
                const name = document.getElementById('parameterName').value;
                const icon = document.getElementById('selectedIcon').value;
                const color = document.getElementById('selectedColor').value;
                const type = document.getElementById('parameterType').value;

                // Validiere die Eingaben
                if (!name || !icon || !color || !type) {
                    showNotification('Bitte f√ºlle alle Pflichtfelder aus.', 'error');
                    return;
                }

                // Sammle typspezifische Daten
                let paramData = { name, icon, color, type };

                if (type === 'number') {
                    paramData.unit = document.getElementById('parameterUnit').value;
                    paramData.minValue = parseFloat(document.getElementById('parameterMinValue').value);
                    paramData.maxValue = parseFloat(document.getElementById('parameterMaxValue').value);

                    if (paramData.minValue >= paramData.maxValue) {
                        showNotification('Der Minimalwert muss kleiner als der Maximalwert sein.', 'error');
                        return;
                    }
                } else if (type === 'select') {
                    // Sammle alle Optionen
                    const options = [];
                    document.querySelectorAll('.parameter-option').forEach((option, index) => {
                        const text = option.querySelector('.option-text').textContent;
                        options.push({
                            value: `option_${index + 1}`,
                            text: text
                        });
                    });

                    if (options.length === 0) {
                        showNotification('Bitte f√ºge mindestens eine Option hinzu.', 'error');
                        return;
                    }

                    paramData.options = options;
                }

                // Speichere den neuen Parameter oder aktualisiere einen bestehenden
                if (currentEditingParameter) {
                    // Aktualisiere bestehenden Parameter
                    updateCustomParameter(currentEditingParameter.id, paramData);
                    showNotification(`Parameter "${name}" wurde aktualisiert.`, 'success');
                } else {
                    // F√ºge neuen Parameter hinzu
                    addCustomParameter(paramData);
                    showNotification(`Neuer Parameter "${name}" wurde hinzugef√ºgt.`, 'success');
                }

                // Schlie√üe den Dialog
                dialog.style.display = 'none';

                // Setze zur√ºck f√ºr n√§chstes Mal
                currentEditingParameter = null;
            });
        }

        // Optionen f√ºr Select-Parameter verwalten
        function updateSelectOptionsList() {
            const optionList = document.getElementById('optionList');
            optionList.innerHTML = '';

            // F√ºge alle vorhandenen Optionen hinzu
            const options = document.querySelectorAll('.parameter-option');

            if (options.length === 0) {
                const emptyMessage = document.createElement('div');
                emptyMessage.textContent = 'Keine Optionen vorhanden. F√ºge unten Optionen hinzu.';
                emptyMessage.style.color = '#666';
                emptyMessage.style.padding = '10px';
                emptyMessage.style.textAlign = 'center';
                optionList.appendChild(emptyMessage);
            } else {
                options.forEach(option => {
                    optionList.appendChild(option);
                });
            }
        }

        // F√ºge eine neue Option f√ºr Select-Parameter hinzu
        function addSelectOption(optionText = null) {
            const optionInput = document.getElementById('newOptionText');
            let text = optionText;

            if (!text) {
                text = optionInput.value.trim();
                if (!text) {
                    showNotification('Bitte gib einen Text f√ºr die Option ein.', 'error');
                    return;
                }
            }

            // Erstelle ein neues Option-Element
            const option = document.createElement('div');
            option.className = 'parameter-option';

            option.innerHTML = `
                <span class="option-text">${text}</span>
                <button type="button" class="delete-option">Entfernen</button>
            `;

            // Event-Listener zum Entfernen der Option
            option.querySelector('.delete-option').addEventListener('click', function() {
                option.remove();
                updateSelectOptionsList();
            });

            // F√ºge die Option zur Liste hinzu
            const optionList = document.getElementById('optionList');
            optionList.appendChild(option);

            // Leere das Eingabefeld
            if (!optionText) {
                optionInput.value = '';
            }

            updateSelectOptionsList();
        }

        // √ñffne den Dialog zum Bearbeiten eines Parameters
        function editCustomParameter(parameter) {
            currentEditingParameter = parameter;

            // Setze den Dialog-Titel
            document.getElementById('parameterDialogTitle').textContent = 'Parameter bearbeiten';

            // F√ºlle die Formulardaten
            document.getElementById('parameterName').value = parameter.name;
            document.getElementById('selectedIcon').value = parameter.icon;
            document.getElementById('selectedColor').value = parameter.color;

            // Setze das ausgew√§hlte Icon
            document.querySelectorAll('#iconSelector .icon-option').forEach(option => {
                if (option.getAttribute('data-icon') === parameter.icon) {
                    option.classList.add('selected');
                } else {
                    option.classList.remove('selected');
                }
            });

            // Setze die ausgew√§hlte Farbe
            document.querySelectorAll('#colorSelector .color-option').forEach(option => {
                if (option.getAttribute('data-color') === parameter.color) {
                    option.classList.add('selected');
                } else {
                    option.classList.remove('selected');
                }
            });

            // Setze den Typ (nur lesbar im Bearbeitungsmodus)
            const typeSelect = document.getElementById('parameterType');
            typeSelect.value = parameter.type;
            typeSelect.disabled = true; // Typ kann nicht ge√§ndert werden nach Erstellung

            // Zeige/verstecke typspezifische Felder
            document.getElementById('numberOptionsContainer').style.display = parameter.type === 'number' ? 'block' : 'none';
            document.getElementById('selectOptionsContainer').style.display = parameter.type === 'select' ? 'block' : 'none';

            // F√ºlle typspezifische Felder
            if (parameter.type === 'number') {
                document.getElementById('parameterUnit').value = parameter.unit || '';
                document.getElementById('parameterMinValue').value = parameter.minValue !== undefined ? parameter.minValue : 0;
                document.getElementById('parameterMaxValue').value = parameter.maxValue !== undefined ? parameter.maxValue : 100;
            } else if (parameter.type === 'select') {
                // Leere die Optionsliste
                document.getElementById('optionList').innerHTML = '';
                document.getElementById('newOptionText').value = '';

                // F√ºge bestehende Optionen hinzu
                if (parameter.options && parameter.options.length > 0) {
                    parameter.options.forEach(option => {
                        addSelectOption(option.text);
                    });
                }
            }

            // √ñffne den Dialog
            document.getElementById('customParameterDialog').style.display = 'flex';
        }

        // √ñffne den Dialog zum Erstellen eines neuen Parameters
        function openNewParameterDialog() {
            currentEditingParameter = null;

            // Setze den Dialog-Titel
            document.getElementById('parameterDialogTitle').textContent = 'Neuer Parameter';

            // Setze das Formular zur√ºck
            document.getElementById('customParameterForm').reset();
            document.getElementById('parameterType').disabled = false;

            // Verstecke alle typspezifischen Container
            document.getElementById('numberOptionsContainer').style.display = 'none';
            document.getElementById('selectOptionsContainer').style.display = 'none';

            // Setze Standardwerte
            document.getElementById('selectedIcon').value = '‚≠ê';
            document.getElementById('selectedColor').value = '#c0ca33';

            // Setze das ausgew√§hlte Icon zur√ºck
            document.querySelectorAll('#iconSelector .icon-option').forEach(option => {
                option.classList.remove('selected');
                if (option.getAttribute('data-icon') === '‚≠ê') {
                    option.classList.add('selected');
                }
            });

            // Setze die ausgew√§hlte Farbe zur√ºck
            document.querySelectorAll('#colorSelector .color-option').forEach(option => {
                option.classList.remove('selected');
                if (option.getAttribute('data-color') === '#c0ca33') {
                    option.classList.add('selected');
                }
            });

            // Leere die Optionsliste
            document.getElementById('optionList').innerHTML = '';

            // √ñffne den Dialog
            document.getElementById('customParameterDialog').style.display = 'flex';
        }

        // Aktualisiere die Statistiken
        function updateStatistics() {
            // Durchschnittliche Zyklusl√§nge
            const avgCycleLength = calculateAvgCycleLength();
            document.getElementById('avgCycleLength').textContent = `${avgCycleLength} Tage`;

            // Durchschnittliche Periodenl√§nge
            const avgPeriodLength = calculateAvgPeriodLength();
            document.getElementById('avgPeriodLength').textContent = `${avgPeriodLength} Tage`;

            // H√§ufigste Symptome
            const topSymptoms = getTopSymptoms();
            if (topSymptoms.length > 0) {
                document.getElementById('topSymptoms').innerHTML = topSymptoms.map(symptom =>
                    `${symptom.name} (${symptom.percentage}%)`
                ).join('<br>');
            } else {
                document.getElementById('topSymptoms').textContent = 'Keine Symptome erfasst';
            }

            // Letzte Zyklen
            const recentCycles = appData.cycles.slice(0, 3);
            if (recentCycles.length > 0) {
                let html = '';

                for (let i = 0; i < recentCycles.length; i++) {
                    const cycle = recentCycles[i];
                    const startDate = new Date(cycle.startDate).toLocaleDateString('de-DE');
                    let endDate = 'aktuell';
                    let length = 'l√§uft noch';

                    if (cycle.endDate) {
                        endDate = new Date(cycle.endDate).toLocaleDateString('de-DE');

                        const start = new Date(cycle.startDate);
                        const end = new Date(cycle.endDate);
                        const diffTime = Math.abs(end - start);
                        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)) + 1;

                        length = `${diffDays} Tage`;
                    }

                    html += `Zyklus ${i + 1}: ${startDate} - ${endDate} (${length})<br>`;
                }

                document.getElementById('recentCycles').innerHTML = html;
            } else {
                document.getElementById('recentCycles').textContent = 'Keine Zyklen erfasst';
            }
        }

        // Aktualisiere die Backup-Einstellungen
        function updateBackupSettings() {
            document.getElementById('autoBackupEnabled').checked = appData.settings.autoBackup.enabled;
            document.getElementById('backupInterval').value = appData.settings.autoBackup.interval;
            document.getElementById('maxBackupsCount').value = appData.settings.autoBackup.maxBackups || 30;
        }

        // CSV-Parser f√ºr den Import
        function parseCSV(csvText) {
            // Einfacher CSV-Parser
            const lines = csvText.split('\n');
            const headers = lines[0].split(',');

            const result = [];

            for (let i = 1; i < lines.length; i++) {
                if (!lines[i].trim()) continue; // √úberspringe leere Zeilen

                const values = lines[i].split(',');
                const entry = {};

                for (let j = 0; j < headers.length; j++) {
                    let value = values[j] || '';

                    // Entferne Anf√ºhrungszeichen bei Texten
                    if (value.startsWith('"') && value.endsWith('"')) {
                        value = value.substring(1, value.length - 1);
                    }

                    // Konvertiere Werte
                    switch (headers[j].trim()) {
                        case 'Datum':
                            entry.date = value;
                            break;
                        case 'Periode':
                            // Konvertiere deutsche Bezeichnungen in Enum-Werte
                            switch (value.trim()) {
                                case 'Keine': entry.flow = 'NONE'; break;
                                case 'Spotting': entry.flow = 'SPOTTING'; break;
                                case 'Leicht': entry.flow = 'LIGHT'; break;
                                case 'Mittel': entry.flow = 'MEDIUM'; break;
                                case 'Stark': entry.flow = 'HEAVY'; break;
                                default: entry.flow = 'NONE';
                            }
                            break;
                        case 'Temperatur':
                            entry.temperature = value ? parseFloat(value) : null;
                            break;
                        case 'Zervixschleim':
                            // Konvertiere deutsche Bezeichnungen in Enum-Werte
                            switch (value.trim()) {
                                case 'Trocken': entry.cervicalMucus = 'DRY'; break;
                                case 'Klebrig': entry.cervicalMucus = 'STICKY'; break;
                                case 'Cremig': entry.cervicalMucus = 'CREAMY'; break;
                                case 'W√§ssrig': entry.cervicalMucus = 'WATERY'; break;
                                case 'Spinnbar': entry.cervicalMucus = 'EGG_WHITE'; break;
                                default: entry.cervicalMucus = null;
                            }
                            break;
                        case 'Brustgef√ºhl':
                            // Konvertiere deutsche Bezeichnungen in Enum-Werte
                            switch (value.trim()) {
                                case 'Keine Beschwerden': entry.breastFeeling = 'NONE'; break;
                                case 'Empfindlich': entry.breastFeeling = 'SENSITIVE'; break;
                                case 'Spannt': entry.breastFeeling = 'TENSE'; break;
                                case 'Schmerzt': entry.breastFeeling = 'PAINFUL'; break;
                                case 'Sehr schmerzhaft': entry.breastFeeling = 'VERY_PAINFUL'; break;
                                default: entry.breastFeeling = null;
                            }
                            break;
                        case 'Symptome':
                            // Konvertiere Symptom-Liste in Array
                            entry.symptoms = value.split(', ').map(symptom => {
                                // Konvertiere deutsche Bezeichnungen in Enum-Werte
                                switch (symptom.trim()) {
                                    case 'Kopfschmerzen': return 'HEADACHE';
                                    case 'Kr√§mpfe': return 'CRAMPS';
                                    case 'R√ºckenschmerzen': return 'BACKACHE';
                                    case 'M√ºdigkeit': return 'FATIGUE';
                                    case 'Bl√§hungen': return 'BLOATING';
                                    case 'Stimmungsschwankungen': return 'MOOD';
                                    default: return '';
                                }
                            }).filter(symptom => symptom); // Entferne leere Eintr√§ge
                            break;
                        case 'Notizen':
                            entry.notes = value;
                            break;
                        default:
                            // Pr√ºfe, ob es sich um einen benutzerdefinierten Parameter handelt
                            const customParam = appData.customParameters.find(p => p.name === headers[j].trim());
                            if (customParam) {
                                if (!entry.customParameters) {
                                    entry.customParameters = {};
                                }

                                if (customParam.type === 'boolean') {
                                    entry.customParameters[customParam.id] = value.trim().toLowerCase() === 'ja';
                                } else if (customParam.type === 'number') {
                                    // Entferne die Einheit, falls vorhanden
                                    let numValue = value.trim();
                                    if (customParam.unit && numValue.endsWith(customParam.unit)) {
                                        numValue = numValue.substring(0, numValue.length - customParam.unit.length).trim();
                                    }
                                    entry.customParameters[customParam.id] = numValue ? parseFloat(numValue) : null;
                                } else if (customParam.type === 'select' && customParam.options) {
                                    // Finde die Option, die diesem Text entspricht
                                    const option = customParam.options.find(opt => opt.text === value.trim());
                                    entry.customParameters[customParam.id] = option ? option.value : value.trim();
                                } else {
                                    entry.customParameters[customParam.id] = value.trim();
                                }
                            }
                    }
                }

                // Erstelle eine ID f√ºr den Eintrag
                entry.id = `imported_${i}_${Date.now()}`;

                result.push(entry);
            }

            return result;
        }

        // Neuberechnung der Zyklen basierend auf den Periodeneintr√§gen
        function recalculateCycles() {
            // Sortiere Eintr√§ge nach Datum
            const sortedEntries = [...appData.entries].sort((a, b) => {
                return new Date(a.date).getTime() - new Date(b.date).getTime();
            });

            // Finde alle Periodeneintr√§ge
            const periodEntries = sortedEntries.filter(entry => entry.flow !== 'NONE');

            if (periodEntries.length === 0) {
                return;
            }

            // Gruppiere Periodeneintr√§ge nach Perioden
            const periods = [];
            let currentPeriod = [periodEntries[0]];

            for (let i = 1; i < periodEntries.length; i++) {
                const prevEntry = periodEntries[i - 1];
                const currentEntry = periodEntries[i];

                const prevDate = new Date(prevEntry.date);
                const currentDate = new Date(currentEntry.date);

                const diffTime = Math.abs(currentDate - prevDate);
                const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

                if (diffDays <= 7) {
                    // Geh√∂rt zur gleichen Periode
                    currentPeriod.push(currentEntry);
                } else {
                    // Neue Periode beginnt
                    periods.push(currentPeriod);
                    currentPeriod = [currentEntry];
                }
            }

            if (currentPeriod.length > 0) {
                periods.push(currentPeriod);
            }

            // Erstelle Zyklen basierend auf den Perioden
            appData.cycles = [];

            for (let i = 0; i < periods.length; i++) {
                const period = periods[i];
                const startDate = period[0].date;

                const cycle = {
                    id: `cycle-${i}`,
                    startDate,
                    endDate: null
                };

                if (i < periods.length - 1) {
                    const nextPeriodStart = periods[i + 1][0].date;
                    const endDate = new Date(nextPeriodStart);
                    endDate.setDate(endDate.getDate() - 1);
                    cycle.endDate = endDate.toISOString().split('T')[0];
                }

                appData.cycles.push(cycle);
            }

            // Sortiere Zyklen nach Startdatum (neueste zuerst)
            appData.cycles.sort((a, b) => {
                return new Date(b.startDate).getTime() - new Date(a.startDate).getTime();
            });
        }

        // Datenexport (JSON und CSV)
        function setupDataExport() {
            // JSON-Export
            document.getElementById('exportDataJson').addEventListener('click', () => {
                const dataStr = JSON.stringify(appData, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `Zykli_backup_${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showNotification('Daten erfolgreich als JSON exportiert!', 'success');
            });

            // CSV-Export
            document.getElementById('exportDataCsv').addEventListener('click', () => {
                exportDataAsCsv();
            });
        }

        // Datenimport
        function setupDataImport() {
            document.getElementById('importData').addEventListener('click', () => {
                const fileInput = document.getElementById('importFile');

                if (fileInput.files.length === 0) {
                    showNotification('Bitte w√§hle eine Datei aus.', 'error');
                    return;
                }

                const file = fileInput.files[0];
                const reader = new FileReader();

                reader.onload = function(event) {
                    try {
                        // Erstelle ein Backup der aktuellen Daten
                        createBackup(false);

                        // Verarbeite die Datei je nach Typ
                        if (file.name.endsWith('.json')) {
                            // JSON-Import
                            const importedData = JSON.parse(event.target.result);

                            // Validiere die importierten Daten
                            if (!importedData.cycles || !importedData.entries) {
                                throw new Error('Ung√ºltiges JSON-Format.');
                            }

                            // Importiere die Daten
                            appData = importedData;

                            // Stelle sicher, dass die Backup-Einstellungen existieren
                            if (!appData.settings.autoBackup) {
                                appData.settings.autoBackup = {
                                    enabled: true,
                                    interval: 7,
                                    lastBackup: null,
                                    maxBackups: 30
                                };
                            } else if (!appData.settings.autoBackup.maxBackups) {
                                appData.settings.autoBackup.maxBackups = 30;
                            }

                            // Stelle sicher, dass das customParameters-Array existiert
                            if (!appData.customParameters) {
                                appData.customParameters = [];
                            }

                            // Aktualisiere die Version
                            appData.version = APP_VERSION;

                            showNotification('JSON-Daten erfolgreich importiert!', 'success');
                        } else if (file.name.endsWith('.csv')) {
                            // CSV-Import
                            const csvText = event.target.result;
                            const importedEntries = parseCSV(csvText);

                            if (importedEntries.length === 0) {
                                throw new Error('Keine g√ºltigen Eintr√§ge in der CSV-Datei gefunden.');
                            }

                            // F√ºge die importierten Eintr√§ge hinzu
                            for (const entry of importedEntries) {
                                // Pr√ºfe, ob bereits ein Eintrag f√ºr dieses Datum existiert
                                const existingEntryIndex = appData.entries.findIndex(e => e.date === entry.date);

                                if (existingEntryIndex !== -1) {
                                    // Aktualisiere den bestehenden Eintrag
                                    appData.entries[existingEntryIndex] = { ...appData.entries[existingEntryIndex], ...entry };
                                } else {
                                    // F√ºge den neuen Eintrag hinzu
                                    appData.entries.push(entry);
                                }
                            }

                            // Neuberechnung der Zyklen
                            recalculateCycles();

                            showNotification(`${importedEntries.length} Eintr√§ge aus CSV erfolgreich importiert!`, 'success');
                        } else {
                            throw new Error('Nicht unterst√ºtztes Dateiformat. Bitte w√§hle eine .json oder .csv Datei.');
                        }

                        saveData();
                        updateUI();
                    } catch (error) {
                        console.error('Import-Fehler:', error);
                        showNotification(`Fehler beim Importieren: ${error.message}`, 'error');
                    }
                };

                if (file.name.endsWith('.json') || file.name.endsWith('.csv')) {
                    reader.readAsText(file);
                } else {
                    showNotification('Nicht unterst√ºtztes Dateiformat. Bitte w√§hle eine .json oder .csv Datei.', 'error');
                }
            });
        }

        // Backup-Einstellungen
        function setupBackupSettings() {
            // Automatisches Backup ein-/ausschalten
            document.getElementById('autoBackupEnabled').addEventListener('change', (event) => {
                appData.settings.autoBackup.enabled = event.target.checked;
                saveData();
            });

            // Backup-Intervall √§ndern
            document.getElementById('backupInterval').addEventListener('change', (event) => {
                const interval = parseInt(event.target.value);
                if (interval > 0 && interval <= 90) {
                    appData.settings.autoBackup.interval = interval;
                    saveData();
                } else {
                    event.target.value = appData.settings.autoBackup.interval;
                    showNotification('Bitte gib einen Wert zwischen 1 und 90 ein.', 'error');
                }
            });

            // Maximale Anzahl von Backups √§ndern
            document.getElementById('maxBackupsCount').addEventListener('change', (event) => {
                const maxBackups = parseInt(event.target.value);
                if (maxBackups >= 5 && maxBackups <= 100) {
                    appData.settings.autoBackup.maxBackups = maxBackups;
                    saveData();
                } else {
                    event.target.value = appData.settings.autoBackup.maxBackups || 30;
                    showNotification('Bitte gib einen Wert zwischen 5 und 100 ein.', 'error');
                }
            });

            // Manuelles Backup erstellen
            document.getElementById('createBackup').addEventListener('click', () => {
                createBackup(false);
            });
        }

        // Daten zur√ºcksetzen
        function setupDataReset() {
            document.getElementById('resetData').addEventListener('click', () => {
                if (confirm('Bist du sicher, dass du alle Daten l√∂schen m√∂chtest? Diese Aktion kann nicht r√ºckg√§ngig gemacht werden.')) {
                    // Erstelle ein Backup der aktuellen Daten
                    createBackup(false);

                    // Initialisiere leeres Datenmodell
                    appData = {
                        cycles: [],
                        entries: [],
                        settings: {
                            cycleLength: 28,
                            periodLength: 5,
                            autoBackup: {
                                enabled: true,
                                interval: 7,
                                lastBackup: null,
                                maxBackups: 30
                            }
                        },
                        customParameters: [],
                        version: APP_VERSION
                    };

                    saveData();

                    showNotification('Alle Daten wurden zur√ºckgesetzt.', 'success');

                    // UI aktualisieren
                    updateUI();
                }
            });
        }

        // Benachrichtigungen
        function setupNotifications() {
            document.getElementById('notificationClose').addEventListener('click', () => {
                document.getElementById('notificationBanner').classList.add('hidden');
            });
        }

        // Setup der t√§glichen Quest
        function setupDailyQuest() {
            // Setze das aktuelle Datum
            updateQuestDate();

            // Navigation zwischen Tagen
            document.getElementById('prevDay').addEventListener('click', () => {
                currentQuestDate.setDate(currentQuestDate.getDate() - 1);
                updateQuestDate();
            });

            document.getElementById('nextDay').addEventListener('click', () => {
                currentQuestDate.setDate(currentQuestDate.getDate() + 1);
                updateQuestDate();
            });

            // Event-Listener f√ºr Quest-Items
            document.querySelectorAll('.quest-item').forEach(item => {
                item.addEventListener('click', () => {
                    const type = item.getAttribute('data-type');
                    const dateString = currentQuestDate.toISOString().split('T')[0];

                    // √ñffne das Eingabeformular f√ºr dieses Datum
                    openEntryForm(dateString);

                    // Fokussiere auf das entsprechende Feld im Formular
                    if (type === 'period') {
                        document.getElementById('flow-none').focus();
                    } else if (type === 'temperature') {
                        document.getElementById('temperature').focus();
                    } else if (type === 'mucus') {
                        document.getElementById('cervicalMucus').focus();
                    } else if (type === 'breast') {
                        document.getElementById('breastFeeling').focus();
                    } else if (type === 'pain') {
                        document.getElementById('symptom-headache').focus();
                    } else if (type === 'mood') {
                        document.getElementById('symptom-mood').focus();
                    } else if (type === 'notes') {
                        document.getElementById('notes').focus();
                    }
                });
            });
        }

        // Setup f√ºr den "Neuer Parameter"-Button
        function setupNewParameterButton() {
            document.getElementById('newCustomParameter').addEventListener('click', () => {
                openNewParameterDialog();
            });
        }

        // Initialisierung
        function init() {
            loadData();
            setupTabs();
            setupDialog();
            setupCalendar();
            setupDailyQuest();
            setupDataExport();
            setupDataImport();
            setupBackupSettings();
            setupDataReset();
            setupNotifications();
            setupParameterDialog();
            setupNewParameterButton();
            updateUI();
        }

        // Starte die App
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>